// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Lstruct.proto
#define PROTOBUF_USE_DLLS

#ifndef GOOGLE_PROTOBUF_INCLUDED_Lstruct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Lstruct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Lstruct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Lstruct_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Lstruct_2eproto;
namespace Protocol {
class CS_Chatting;
struct CS_ChattingDefaultTypeInternal;
extern CS_ChattingDefaultTypeInternal _CS_Chatting_default_instance_;
class CS_Join;
struct CS_JoinDefaultTypeInternal;
extern CS_JoinDefaultTypeInternal _CS_Join_default_instance_;
class CS_Leave;
struct CS_LeaveDefaultTypeInternal;
extern CS_LeaveDefaultTypeInternal _CS_Leave_default_instance_;
class CS_Login;
struct CS_LoginDefaultTypeInternal;
extern CS_LoginDefaultTypeInternal _CS_Login_default_instance_;
class CS_Ready;
struct CS_ReadyDefaultTypeInternal;
extern CS_ReadyDefaultTypeInternal _CS_Ready_default_instance_;
class CS_Register;
struct CS_RegisterDefaultTypeInternal;
extern CS_RegisterDefaultTypeInternal _CS_Register_default_instance_;
class SC_Chatting;
struct SC_ChattingDefaultTypeInternal;
extern SC_ChattingDefaultTypeInternal _SC_Chatting_default_instance_;
class SC_Join;
struct SC_JoinDefaultTypeInternal;
extern SC_JoinDefaultTypeInternal _SC_Join_default_instance_;
class SC_JoinPlayer;
struct SC_JoinPlayerDefaultTypeInternal;
extern SC_JoinPlayerDefaultTypeInternal _SC_JoinPlayer_default_instance_;
class SC_LeavePlayer;
struct SC_LeavePlayerDefaultTypeInternal;
extern SC_LeavePlayerDefaultTypeInternal _SC_LeavePlayer_default_instance_;
class SC_Login;
struct SC_LoginDefaultTypeInternal;
extern SC_LoginDefaultTypeInternal _SC_Login_default_instance_;
class SC_Ready;
struct SC_ReadyDefaultTypeInternal;
extern SC_ReadyDefaultTypeInternal _SC_Ready_default_instance_;
class SC_Register;
struct SC_RegisterDefaultTypeInternal;
extern SC_RegisterDefaultTypeInternal _SC_Register_default_instance_;
class Select_Character;
struct Select_CharacterDefaultTypeInternal;
extern Select_CharacterDefaultTypeInternal _Select_Character_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::CS_Chatting* Arena::CreateMaybeMessage<::Protocol::CS_Chatting>(Arena*);
template<> ::Protocol::CS_Join* Arena::CreateMaybeMessage<::Protocol::CS_Join>(Arena*);
template<> ::Protocol::CS_Leave* Arena::CreateMaybeMessage<::Protocol::CS_Leave>(Arena*);
template<> ::Protocol::CS_Login* Arena::CreateMaybeMessage<::Protocol::CS_Login>(Arena*);
template<> ::Protocol::CS_Ready* Arena::CreateMaybeMessage<::Protocol::CS_Ready>(Arena*);
template<> ::Protocol::CS_Register* Arena::CreateMaybeMessage<::Protocol::CS_Register>(Arena*);
template<> ::Protocol::SC_Chatting* Arena::CreateMaybeMessage<::Protocol::SC_Chatting>(Arena*);
template<> ::Protocol::SC_Join* Arena::CreateMaybeMessage<::Protocol::SC_Join>(Arena*);
template<> ::Protocol::SC_JoinPlayer* Arena::CreateMaybeMessage<::Protocol::SC_JoinPlayer>(Arena*);
template<> ::Protocol::SC_LeavePlayer* Arena::CreateMaybeMessage<::Protocol::SC_LeavePlayer>(Arena*);
template<> ::Protocol::SC_Login* Arena::CreateMaybeMessage<::Protocol::SC_Login>(Arena*);
template<> ::Protocol::SC_Ready* Arena::CreateMaybeMessage<::Protocol::SC_Ready>(Arena*);
template<> ::Protocol::SC_Register* Arena::CreateMaybeMessage<::Protocol::SC_Register>(Arena*);
template<> ::Protocol::Select_Character* Arena::CreateMaybeMessage<::Protocol::Select_Character>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class CS_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Login) */ {
 public:
  inline CS_Login() : CS_Login(nullptr) {}
  ~CS_Login() override;
  explicit PROTOBUF_CONSTEXPR CS_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Login(const CS_Login& from);
  CS_Login(CS_Login&& from) noexcept
    : CS_Login() {
    *this = ::std::move(from);
  }

  inline CS_Login& operator=(const CS_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Login& operator=(CS_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Login* internal_default_instance() {
    return reinterpret_cast<const CS_Login*>(
               &_CS_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CS_Login& a, CS_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Login& from) {
    CS_Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Login";
  }
  protected:
  explicit CS_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class CS_Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Register) */ {
 public:
  inline CS_Register() : CS_Register(nullptr) {}
  ~CS_Register() override;
  explicit PROTOBUF_CONSTEXPR CS_Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Register(const CS_Register& from);
  CS_Register(CS_Register&& from) noexcept
    : CS_Register() {
    *this = ::std::move(from);
  }

  inline CS_Register& operator=(const CS_Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Register& operator=(CS_Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Register* internal_default_instance() {
    return reinterpret_cast<const CS_Register*>(
               &_CS_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CS_Register& a, CS_Register& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Register& from) {
    CS_Register::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Register* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Register";
  }
  protected:
  explicit CS_Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_Login) */ {
 public:
  inline SC_Login() : SC_Login(nullptr) {}
  ~SC_Login() override;
  explicit PROTOBUF_CONSTEXPR SC_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Login(const SC_Login& from);
  SC_Login(SC_Login&& from) noexcept
    : SC_Login() {
    *this = ::std::move(from);
  }

  inline SC_Login& operator=(const SC_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Login& operator=(SC_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Login* internal_default_instance() {
    return reinterpret_cast<const SC_Login*>(
               &_SC_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SC_Login& a, SC_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Login& from) {
    SC_Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_Login";
  }
  protected:
  explicit SC_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBLoginFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool b_login = 2;
  void clear_b_login();
  bool b_login() const;
  void set_b_login(bool value);
  private:
  bool _internal_b_login() const;
  void _internal_set_b_login(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    bool b_login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_Register) */ {
 public:
  inline SC_Register() : SC_Register(nullptr) {}
  ~SC_Register() override;
  explicit PROTOBUF_CONSTEXPR SC_Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Register(const SC_Register& from);
  SC_Register(SC_Register&& from) noexcept
    : SC_Register() {
    *this = ::std::move(from);
  }

  inline SC_Register& operator=(const SC_Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Register& operator=(SC_Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Register* internal_default_instance() {
    return reinterpret_cast<const SC_Register*>(
               &_SC_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SC_Register& a, SC_Register& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Register& from) {
    SC_Register::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Register* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_Register";
  }
  protected:
  explicit SC_Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBRegisterFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool b_register = 2;
  void clear_b_register();
  bool b_register() const;
  void set_b_register(bool value);
  private:
  bool _internal_b_register() const;
  void _internal_set_b_register(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    bool b_register_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class CS_Ready final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Ready) */ {
 public:
  inline CS_Ready() : CS_Ready(nullptr) {}
  ~CS_Ready() override;
  explicit PROTOBUF_CONSTEXPR CS_Ready(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Ready(const CS_Ready& from);
  CS_Ready(CS_Ready&& from) noexcept
    : CS_Ready() {
    *this = ::std::move(from);
  }

  inline CS_Ready& operator=(const CS_Ready& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Ready& operator=(CS_Ready&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Ready& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Ready* internal_default_instance() {
    return reinterpret_cast<const CS_Ready*>(
               &_CS_Ready_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CS_Ready& a, CS_Ready& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Ready* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Ready* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Ready* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Ready>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Ready& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Ready& from) {
    CS_Ready::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Ready* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Ready";
  }
  protected:
  explicit CS_Ready(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
    kReadyFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // bool ready = 3;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Ready)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t playerid_;
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_Ready final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_Ready) */ {
 public:
  inline SC_Ready() : SC_Ready(nullptr) {}
  ~SC_Ready() override;
  explicit PROTOBUF_CONSTEXPR SC_Ready(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Ready(const SC_Ready& from);
  SC_Ready(SC_Ready&& from) noexcept
    : SC_Ready() {
    *this = ::std::move(from);
  }

  inline SC_Ready& operator=(const SC_Ready& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Ready& operator=(SC_Ready&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Ready& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Ready* internal_default_instance() {
    return reinterpret_cast<const SC_Ready*>(
               &_SC_Ready_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SC_Ready& a, SC_Ready& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Ready* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Ready* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Ready* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Ready>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Ready& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Ready& from) {
    SC_Ready::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Ready* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_Ready";
  }
  protected:
  explicit SC_Ready(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kAllreadyFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool allready = 2;
  void clear_allready();
  bool allready() const;
  void set_allready(bool value);
  private:
  bool _internal_allready() const;
  void _internal_set_allready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_Ready)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    bool allready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class Select_Character final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Select_Character) */ {
 public:
  inline Select_Character() : Select_Character(nullptr) {}
  ~Select_Character() override;
  explicit PROTOBUF_CONSTEXPR Select_Character(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Select_Character(const Select_Character& from);
  Select_Character(Select_Character&& from) noexcept
    : Select_Character() {
    *this = ::std::move(from);
  }

  inline Select_Character& operator=(const Select_Character& from) {
    CopyFrom(from);
    return *this;
  }
  inline Select_Character& operator=(Select_Character&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Select_Character& default_instance() {
    return *internal_default_instance();
  }
  static inline const Select_Character* internal_default_instance() {
    return reinterpret_cast<const Select_Character*>(
               &_Select_Character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Select_Character& a, Select_Character& b) {
    a.Swap(&b);
  }
  inline void Swap(Select_Character* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Select_Character* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Select_Character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Select_Character>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Select_Character& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Select_Character& from) {
    Select_Character::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Select_Character* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Select_Character";
  }
  protected:
  explicit Select_Character(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
    kCharacterTypeFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // uint32 character_type = 3;
  void clear_character_type();
  uint32_t character_type() const;
  void set_character_type(uint32_t value);
  private:
  uint32_t _internal_character_type() const;
  void _internal_set_character_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Select_Character)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t playerid_;
    uint32_t character_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class CS_Join final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Join) */ {
 public:
  inline CS_Join() : CS_Join(nullptr) {}
  ~CS_Join() override;
  explicit PROTOBUF_CONSTEXPR CS_Join(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Join(const CS_Join& from);
  CS_Join(CS_Join&& from) noexcept
    : CS_Join() {
    *this = ::std::move(from);
  }

  inline CS_Join& operator=(const CS_Join& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Join& operator=(CS_Join&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Join& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Join* internal_default_instance() {
    return reinterpret_cast<const CS_Join*>(
               &_CS_Join_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CS_Join& a, CS_Join& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Join* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Join* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Join* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Join>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Join& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Join& from) {
    CS_Join::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Join* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Join";
  }
  protected:
  explicit CS_Join(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
    kRoomidFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // uint32 roomid = 3;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Join)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t playerid_;
    uint32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_Join final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_Join) */ {
 public:
  inline SC_Join() : SC_Join(nullptr) {}
  ~SC_Join() override;
  explicit PROTOBUF_CONSTEXPR SC_Join(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Join(const SC_Join& from);
  SC_Join(SC_Join&& from) noexcept
    : SC_Join() {
    *this = ::std::move(from);
  }

  inline SC_Join& operator=(const SC_Join& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Join& operator=(SC_Join&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Join& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Join* internal_default_instance() {
    return reinterpret_cast<const SC_Join*>(
               &_SC_Join_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SC_Join& a, SC_Join& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Join* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Join* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Join* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Join>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Join& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Join& from) {
    SC_Join::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Join* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_Join";
  }
  protected:
  explicit SC_Join(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kBJoinFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // bool b_join = 2;
  void clear_b_join();
  bool b_join() const;
  void set_b_join(bool value);
  private:
  bool _internal_b_join() const;
  void _internal_set_b_join(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_Join)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    bool b_join_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_JoinPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_JoinPlayer) */ {
 public:
  inline SC_JoinPlayer() : SC_JoinPlayer(nullptr) {}
  ~SC_JoinPlayer() override;
  explicit PROTOBUF_CONSTEXPR SC_JoinPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_JoinPlayer(const SC_JoinPlayer& from);
  SC_JoinPlayer(SC_JoinPlayer&& from) noexcept
    : SC_JoinPlayer() {
    *this = ::std::move(from);
  }

  inline SC_JoinPlayer& operator=(const SC_JoinPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_JoinPlayer& operator=(SC_JoinPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_JoinPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_JoinPlayer* internal_default_instance() {
    return reinterpret_cast<const SC_JoinPlayer*>(
               &_SC_JoinPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SC_JoinPlayer& a, SC_JoinPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_JoinPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_JoinPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_JoinPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_JoinPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_JoinPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_JoinPlayer& from) {
    SC_JoinPlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_JoinPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_JoinPlayer";
  }
  protected:
  explicit SC_JoinPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_JoinPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t type_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class CS_Leave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Leave) */ {
 public:
  inline CS_Leave() : CS_Leave(nullptr) {}
  ~CS_Leave() override;
  explicit PROTOBUF_CONSTEXPR CS_Leave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Leave(const CS_Leave& from);
  CS_Leave(CS_Leave&& from) noexcept
    : CS_Leave() {
    *this = ::std::move(from);
  }

  inline CS_Leave& operator=(const CS_Leave& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Leave& operator=(CS_Leave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Leave& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Leave* internal_default_instance() {
    return reinterpret_cast<const CS_Leave*>(
               &_CS_Leave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CS_Leave& a, CS_Leave& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Leave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Leave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Leave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Leave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Leave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Leave& from) {
    CS_Leave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Leave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Leave";
  }
  protected:
  explicit CS_Leave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
    kRoomidFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // uint32 roomid = 3;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Leave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t playerid_;
    uint32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_LeavePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_LeavePlayer) */ {
 public:
  inline SC_LeavePlayer() : SC_LeavePlayer(nullptr) {}
  ~SC_LeavePlayer() override;
  explicit PROTOBUF_CONSTEXPR SC_LeavePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_LeavePlayer(const SC_LeavePlayer& from);
  SC_LeavePlayer(SC_LeavePlayer&& from) noexcept
    : SC_LeavePlayer() {
    *this = ::std::move(from);
  }

  inline SC_LeavePlayer& operator=(const SC_LeavePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_LeavePlayer& operator=(SC_LeavePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_LeavePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_LeavePlayer* internal_default_instance() {
    return reinterpret_cast<const SC_LeavePlayer*>(
               &_SC_LeavePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SC_LeavePlayer& a, SC_LeavePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_LeavePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_LeavePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_LeavePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_LeavePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_LeavePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_LeavePlayer& from) {
    SC_LeavePlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_LeavePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_LeavePlayer";
  }
  protected:
  explicit SC_LeavePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
  };
  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_LeavePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t type_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class CS_Chatting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CS_Chatting) */ {
 public:
  inline CS_Chatting() : CS_Chatting(nullptr) {}
  ~CS_Chatting() override;
  explicit PROTOBUF_CONSTEXPR CS_Chatting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CS_Chatting(const CS_Chatting& from);
  CS_Chatting(CS_Chatting&& from) noexcept
    : CS_Chatting() {
    *this = ::std::move(from);
  }

  inline CS_Chatting& operator=(const CS_Chatting& from) {
    CopyFrom(from);
    return *this;
  }
  inline CS_Chatting& operator=(CS_Chatting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CS_Chatting& default_instance() {
    return *internal_default_instance();
  }
  static inline const CS_Chatting* internal_default_instance() {
    return reinterpret_cast<const CS_Chatting*>(
               &_CS_Chatting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CS_Chatting& a, CS_Chatting& b) {
    a.Swap(&b);
  }
  inline void Swap(CS_Chatting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CS_Chatting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CS_Chatting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CS_Chatting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CS_Chatting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CS_Chatting& from) {
    CS_Chatting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CS_Chatting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CS_Chatting";
  }
  protected:
  explicit CS_Chatting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 3,
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
  };
  // string chat = 3;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CS_Chatting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    uint32_t type_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// -------------------------------------------------------------------

class SC_Chatting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SC_Chatting) */ {
 public:
  inline SC_Chatting() : SC_Chatting(nullptr) {}
  ~SC_Chatting() override;
  explicit PROTOBUF_CONSTEXPR SC_Chatting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SC_Chatting(const SC_Chatting& from);
  SC_Chatting(SC_Chatting&& from) noexcept
    : SC_Chatting() {
    *this = ::std::move(from);
  }

  inline SC_Chatting& operator=(const SC_Chatting& from) {
    CopyFrom(from);
    return *this;
  }
  inline SC_Chatting& operator=(SC_Chatting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SC_Chatting& default_instance() {
    return *internal_default_instance();
  }
  static inline const SC_Chatting* internal_default_instance() {
    return reinterpret_cast<const SC_Chatting*>(
               &_SC_Chatting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SC_Chatting& a, SC_Chatting& b) {
    a.Swap(&b);
  }
  inline void Swap(SC_Chatting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SC_Chatting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SC_Chatting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SC_Chatting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SC_Chatting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SC_Chatting& from) {
    SC_Chatting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SC_Chatting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SC_Chatting";
  }
  protected:
  explicit SC_Chatting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 3,
    kTypeFieldNumber = 1,
    kPlayeridFieldNumber = 2,
  };
  // string chat = 3;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 playerid = 2;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SC_Chatting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    uint32_t type_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Lstruct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CS_Login

// uint32 type = 1;
inline void CS_Login::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Login::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Login::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Login.type)
  return _internal_type();
}
inline void CS_Login::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Login::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Login.type)
}

// string id = 2;
inline void CS_Login::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CS_Login::id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Login.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_Login.id)
}
inline std::string* CS_Login::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_Login.id)
  return _s;
}
inline const std::string& CS_Login::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CS_Login::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_Login::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_Login::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.CS_Login.id)
  return _impl_.id_.Release();
}
inline void CS_Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_Login.id)
}

// string password = 3;
inline void CS_Login::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CS_Login::password() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Login.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_Login::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_Login.password)
}
inline std::string* CS_Login::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_Login.password)
  return _s;
}
inline const std::string& CS_Login::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CS_Login::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_Login::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_Login::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.CS_Login.password)
  return _impl_.password_.Release();
}
inline void CS_Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_Login.password)
}

// -------------------------------------------------------------------

// CS_Register

// uint32 type = 1;
inline void CS_Register::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Register::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Register::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Register.type)
  return _internal_type();
}
inline void CS_Register::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Register::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Register.type)
}

// string id = 2;
inline void CS_Register::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CS_Register::id() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Register.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_Register::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_Register.id)
}
inline std::string* CS_Register::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_Register.id)
  return _s;
}
inline const std::string& CS_Register::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CS_Register::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_Register::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_Register::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.CS_Register.id)
  return _impl_.id_.Release();
}
inline void CS_Register::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_Register.id)
}

// string password = 3;
inline void CS_Register::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CS_Register::password() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Register.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_Register::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_Register.password)
}
inline std::string* CS_Register::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_Register.password)
  return _s;
}
inline const std::string& CS_Register::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CS_Register::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_Register::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_Register::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.CS_Register.password)
  return _impl_.password_.Release();
}
inline void CS_Register::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_Register.password)
}

// -------------------------------------------------------------------

// SC_Login

// uint32 type = 1;
inline void SC_Login::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_Login::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_Login::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Login.type)
  return _internal_type();
}
inline void SC_Login::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_Login::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Login.type)
}

// bool b_login = 2;
inline void SC_Login::clear_b_login() {
  _impl_.b_login_ = false;
}
inline bool SC_Login::_internal_b_login() const {
  return _impl_.b_login_;
}
inline bool SC_Login::b_login() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Login.b_login)
  return _internal_b_login();
}
inline void SC_Login::_internal_set_b_login(bool value) {
  
  _impl_.b_login_ = value;
}
inline void SC_Login::set_b_login(bool value) {
  _internal_set_b_login(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Login.b_login)
}

// -------------------------------------------------------------------

// SC_Register

// uint32 type = 1;
inline void SC_Register::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_Register::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_Register::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Register.type)
  return _internal_type();
}
inline void SC_Register::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_Register::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Register.type)
}

// bool b_register = 2;
inline void SC_Register::clear_b_register() {
  _impl_.b_register_ = false;
}
inline bool SC_Register::_internal_b_register() const {
  return _impl_.b_register_;
}
inline bool SC_Register::b_register() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Register.b_register)
  return _internal_b_register();
}
inline void SC_Register::_internal_set_b_register(bool value) {
  
  _impl_.b_register_ = value;
}
inline void SC_Register::set_b_register(bool value) {
  _internal_set_b_register(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Register.b_register)
}

// -------------------------------------------------------------------

// CS_Ready

// uint32 type = 1;
inline void CS_Ready::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Ready::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Ready::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Ready.type)
  return _internal_type();
}
inline void CS_Ready::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Ready::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Ready.type)
}

// uint32 playerid = 2;
inline void CS_Ready::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t CS_Ready::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CS_Ready::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Ready.playerid)
  return _internal_playerid();
}
inline void CS_Ready::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void CS_Ready::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Ready.playerid)
}

// bool ready = 3;
inline void CS_Ready::clear_ready() {
  _impl_.ready_ = false;
}
inline bool CS_Ready::_internal_ready() const {
  return _impl_.ready_;
}
inline bool CS_Ready::ready() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Ready.ready)
  return _internal_ready();
}
inline void CS_Ready::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void CS_Ready::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Ready.ready)
}

// -------------------------------------------------------------------

// SC_Ready

// uint32 type = 1;
inline void SC_Ready::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_Ready::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_Ready::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Ready.type)
  return _internal_type();
}
inline void SC_Ready::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_Ready::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Ready.type)
}

// bool allready = 2;
inline void SC_Ready::clear_allready() {
  _impl_.allready_ = false;
}
inline bool SC_Ready::_internal_allready() const {
  return _impl_.allready_;
}
inline bool SC_Ready::allready() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Ready.allready)
  return _internal_allready();
}
inline void SC_Ready::_internal_set_allready(bool value) {
  
  _impl_.allready_ = value;
}
inline void SC_Ready::set_allready(bool value) {
  _internal_set_allready(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Ready.allready)
}

// -------------------------------------------------------------------

// Select_Character

// uint32 type = 1;
inline void Select_Character::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t Select_Character::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t Select_Character::type() const {
  // @@protoc_insertion_point(field_get:Protocol.Select_Character.type)
  return _internal_type();
}
inline void Select_Character::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void Select_Character::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Select_Character.type)
}

// uint32 playerid = 2;
inline void Select_Character::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t Select_Character::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t Select_Character::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.Select_Character.playerid)
  return _internal_playerid();
}
inline void Select_Character::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void Select_Character::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.Select_Character.playerid)
}

// uint32 character_type = 3;
inline void Select_Character::clear_character_type() {
  _impl_.character_type_ = 0u;
}
inline uint32_t Select_Character::_internal_character_type() const {
  return _impl_.character_type_;
}
inline uint32_t Select_Character::character_type() const {
  // @@protoc_insertion_point(field_get:Protocol.Select_Character.character_type)
  return _internal_character_type();
}
inline void Select_Character::_internal_set_character_type(uint32_t value) {
  
  _impl_.character_type_ = value;
}
inline void Select_Character::set_character_type(uint32_t value) {
  _internal_set_character_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Select_Character.character_type)
}

// -------------------------------------------------------------------

// CS_Join

// uint32 type = 1;
inline void CS_Join::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Join::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Join::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Join.type)
  return _internal_type();
}
inline void CS_Join::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Join::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Join.type)
}

// uint32 playerid = 2;
inline void CS_Join::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t CS_Join::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CS_Join::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Join.playerid)
  return _internal_playerid();
}
inline void CS_Join::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void CS_Join::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Join.playerid)
}

// uint32 roomid = 3;
inline void CS_Join::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t CS_Join::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t CS_Join::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Join.roomid)
  return _internal_roomid();
}
inline void CS_Join::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void CS_Join::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Join.roomid)
}

// -------------------------------------------------------------------

// SC_Join

// uint32 type = 1;
inline void SC_Join::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_Join::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_Join::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Join.type)
  return _internal_type();
}
inline void SC_Join::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_Join::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Join.type)
}

// bool b_join = 2;
inline void SC_Join::clear_b_join() {
  _impl_.b_join_ = false;
}
inline bool SC_Join::_internal_b_join() const {
  return _impl_.b_join_;
}
inline bool SC_Join::b_join() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Join.b_join)
  return _internal_b_join();
}
inline void SC_Join::_internal_set_b_join(bool value) {
  
  _impl_.b_join_ = value;
}
inline void SC_Join::set_b_join(bool value) {
  _internal_set_b_join(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Join.b_join)
}

// -------------------------------------------------------------------

// SC_JoinPlayer

// uint32 type = 1;
inline void SC_JoinPlayer::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_JoinPlayer::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_JoinPlayer::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_JoinPlayer.type)
  return _internal_type();
}
inline void SC_JoinPlayer::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_JoinPlayer::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_JoinPlayer.type)
}

// uint32 playerid = 2;
inline void SC_JoinPlayer::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t SC_JoinPlayer::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t SC_JoinPlayer::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_JoinPlayer.playerid)
  return _internal_playerid();
}
inline void SC_JoinPlayer::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void SC_JoinPlayer::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_JoinPlayer.playerid)
}

// string name = 3;
inline void SC_JoinPlayer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SC_JoinPlayer::name() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_JoinPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_JoinPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_JoinPlayer.name)
}
inline std::string* SC_JoinPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_JoinPlayer.name)
  return _s;
}
inline const std::string& SC_JoinPlayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SC_JoinPlayer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_JoinPlayer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_JoinPlayer::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.SC_JoinPlayer.name)
  return _impl_.name_.Release();
}
inline void SC_JoinPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_JoinPlayer.name)
}

// -------------------------------------------------------------------

// CS_Leave

// uint32 type = 1;
inline void CS_Leave::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Leave::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Leave::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Leave.type)
  return _internal_type();
}
inline void CS_Leave::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Leave::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Leave.type)
}

// uint32 playerid = 2;
inline void CS_Leave::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t CS_Leave::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CS_Leave::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Leave.playerid)
  return _internal_playerid();
}
inline void CS_Leave::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void CS_Leave::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Leave.playerid)
}

// uint32 roomid = 3;
inline void CS_Leave::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t CS_Leave::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t CS_Leave::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Leave.roomid)
  return _internal_roomid();
}
inline void CS_Leave::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void CS_Leave::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Leave.roomid)
}

// -------------------------------------------------------------------

// SC_LeavePlayer

// uint32 type = 1;
inline void SC_LeavePlayer::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_LeavePlayer::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_LeavePlayer::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LeavePlayer.type)
  return _internal_type();
}
inline void SC_LeavePlayer::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_LeavePlayer::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_LeavePlayer.type)
}

// uint32 playerid = 2;
inline void SC_LeavePlayer::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t SC_LeavePlayer::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t SC_LeavePlayer::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_LeavePlayer.playerid)
  return _internal_playerid();
}
inline void SC_LeavePlayer::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void SC_LeavePlayer::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_LeavePlayer.playerid)
}

// -------------------------------------------------------------------

// CS_Chatting

// uint32 type = 1;
inline void CS_Chatting::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t CS_Chatting::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t CS_Chatting::type() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Chatting.type)
  return _internal_type();
}
inline void CS_Chatting::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void CS_Chatting::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Chatting.type)
}

// uint32 playerid = 2;
inline void CS_Chatting::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t CS_Chatting::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t CS_Chatting::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Chatting.playerid)
  return _internal_playerid();
}
inline void CS_Chatting::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void CS_Chatting::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.CS_Chatting.playerid)
}

// string chat = 3;
inline void CS_Chatting::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& CS_Chatting::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.CS_Chatting.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CS_Chatting::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CS_Chatting.chat)
}
inline std::string* CS_Chatting::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.CS_Chatting.chat)
  return _s;
}
inline const std::string& CS_Chatting::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void CS_Chatting::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* CS_Chatting::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* CS_Chatting::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.CS_Chatting.chat)
  return _impl_.chat_.Release();
}
inline void CS_Chatting::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CS_Chatting.chat)
}

// -------------------------------------------------------------------

// SC_Chatting

// uint32 type = 1;
inline void SC_Chatting::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t SC_Chatting::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t SC_Chatting::type() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Chatting.type)
  return _internal_type();
}
inline void SC_Chatting::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void SC_Chatting::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Chatting.type)
}

// uint32 playerid = 2;
inline void SC_Chatting::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t SC_Chatting::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t SC_Chatting::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Chatting.playerid)
  return _internal_playerid();
}
inline void SC_Chatting::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void SC_Chatting::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.SC_Chatting.playerid)
}

// string chat = 3;
inline void SC_Chatting::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& SC_Chatting::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.SC_Chatting.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SC_Chatting::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SC_Chatting.chat)
}
inline std::string* SC_Chatting::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.SC_Chatting.chat)
  return _s;
}
inline const std::string& SC_Chatting::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void SC_Chatting::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* SC_Chatting::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* SC_Chatting::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.SC_Chatting.chat)
  return _impl_.chat_.Release();
}
inline void SC_Chatting::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SC_Chatting.chat)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Lstruct_2eproto
