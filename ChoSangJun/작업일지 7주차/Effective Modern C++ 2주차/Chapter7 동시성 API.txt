


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.12 공부
// Chapter7 동시성 API
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>
#include <list>
#include <thread>

#include "save.h"

// 항목 35: 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라

//int doAsynWork();
//
//std::thread t(doAsyncWork);
//
//
//// 과제 기반 프로그래밍
//auto fut = std::async(doAsynWork); // fut은 future를 뜻함
// 스레드 관리 부담을 표준 라이브러리 구현자들에게 떠넘긴다.

// ## 쭉 보면서 여러 정보들이 지금도 쓰고 있는 건지 의문이 들기는 한다. ##

// 기억해 둘 사항들
// - std::thread API에서는 비동기적으로 실행된 함수의 반환값을 직접 얻을 수 없으며,
//   만일 그런 함수가 예외를 던지면 프로그램이 종료된다.
// - 스레드 기반 프로그래밍에서는 스레드 고갈, 과다구독, 부하 균형화, 새 플랫폼으로의 적응을 독자가 직접 처리해야 한다.
// - std::async와 기본 시동 방침을 이용한 과제 기반 프로그래밍은 그런 대부분의 문제를 알아서 처리해준다.

// 항목 36: 비동기성이 필수일 때에는 std::launch::async를 지정하라
// - 시동 방침을 지정하면 f는 반드시 비동기적으로, 다시 말해서 다른 스레드에서 실행된다.

// 항목 37: std::thread들을 모든 경로에서 합류 불가능하게 만들어라
// 기억해 둘 사항들
// - 모든 경로에서 std::thread를 합류 불가능으로 만들어라
// - 소멸 시 join 방식은 디버깅하기 어려운 성능 이상으로 이어질 수 있다.
// - 자료 멤버 목록에서 std::thread 객체를 마지막에 선언하라

// 항목 38: 스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라
// - std::async를 통해서 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는
//   과제가 완료될 때까지 차단된다.
// - 다른 모든 미래 객체의 소멸자는 그냥 해당 미래 객체를 파괴한다.

// 항목 39: 단발성 사건 통신에는 void 미래 객체를 고려하라
// 기억해 둘 사항들
// - 간단한 사건 통신을 수행할 때, 조건 변수 기반 설계에는 여분의 뮤텍스가 필요하고
//   검출 과제와 반응 과제의 진행 순서에 제약이 있으며, 사건이 실제로 발생했는지를 반응 과제가 다시 확인해야 한다.
// - 플래그 기반 설계를 사용하면 그런단점들이 없지만, 대신 차단이 아니라 폴링이 일어난다는 단점이 있다.
// - 조건 변수와 플래그를 조합할 수도 있으나, 그런 조합을 이용한 통신 매커니즘은 필요 이상으로 복잡하다.
// - std::promise와 미래 객체를 사용하면 이러한 문제점들을 피할 수 있지만, 그런 접근방식은
//   공유 상태에 힙 메모리를 사용하며, 단발성 통신만 가능하다.

// 항목 40: 동시성에는 std::atomic을 사용하고 volatile은 특별한 메모리에 사용하라
// 기억해 둘 사항들
// - std::atomic은 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것으로, 동시적 소프트웨어의 작성을 위한 도구이다.
// - volatile은 읽기와 기록을 최적화로 제거하지 말아햐 하는 메모리를 위한 것으로, 특별한 메모리를 다룰 때
//   필요한 도구이다.



int main()
{


    save("EffectiveModernC++Study.cpp");
}


================================================
