


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.11 공부
// Chapter5 오른값 참조, 이동 의미론, 완벽 전달
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>
#include <list>

#include "save.h"

// 항목 23: std::move와 std::forward를 숙지하라
// 기억해 둘 사항들
// - std::move는 오른값으로의 무조건 캐스팅을 수행한다. std::move 자체는 아무것도 이동하지 않는다.
// - std::forward는 주어진 인수가 오른값에 묶인 경우에만 그것을 오른값으로 캐스팅한다.
// - std::move와 std::forward 둘 다 실행시점에서는 아무 일도 하지 않는다.

// 항목 24: 보편 참조와 오른값 참조를 구별하라
// 기억해 둘 사항들
// - 함수 템플릿 매개변수의 형식이 T&& 형태이고 T가 연역된다면, 또는 객체를 auto&&로 선언한다면,
//   그 매개변수나 객체는 보편 참조이다.
// - 형식 선언의 형태가 정확히 형식&&가 아니며, 또는 형식 연역이 일어나지 않으면, 형식&&는 오른값 참조를 뜻한다.
// - 오른값으로 초기화되는 보편 참조는 오른값 참조에 해당한다. 왼값으로 초기화되는 보편 참조는 왼값 참조에 해당한다.

// 항목 25: 오른값 참조에는 std::move를, 보편 참조에는 std::forward를 사용하라
// 기억해 둘 사항들
// 오른값 참조에는 std::move를, 보편 참조에는 std::forward를 적용하라

// 항목 26: 보편 참조에 대한 중복적재를 피하라

// 항목 27: 보편 참조에 대한 중복적재 대신 사용할 수 있는 기법들을 알아 두라
// - 중복 적재를 포기한다.
// - const T& 매개변수를 사용한다.
// - 값 전달 방식의 매개변수를 사용한다.
// - 꼬리표 배분을 사용한다.
// - 보편 참조를 받는 템플릿을 제한한다.

// 항목 28: 참조 축약을 숙지하라
// 기억해 둘 사항들
// - 참조 축약은 템플릿 인스턴스화, auto 형식 연역, typedef와 별칭 선언의 지정 및 사용, decltype의
//   지정 및 사용이라는 네 가지 문맥에서 일어난다.

// 항목 29: 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라
// - 이동 연산이 없다: 복사 요청이 된다.
// - 이동이 더 빠르지 않다
// - 이동을 사용할 수 없다: noexcept로 선언되어 있지 않다.
// - 원본 객체가 왼값이다.

// 항목 30: 완벽 전달이 실패하는 경우들을 잘 알아두라  -> 원본을 전달하는 것을 말하는 것 같다.
// 기억해 둘 사항들
// - 완벽 전달은 템플릿 형식 연역이 실패하거나 틀린 연역이 실패하거나 틀린 형식을 연역했을 때 실패한다.


int main()
{


    save("EffectiveModernC++Study.cpp");
}


================================================
