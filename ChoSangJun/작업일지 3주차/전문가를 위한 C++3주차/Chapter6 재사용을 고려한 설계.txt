


================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.12 공부
// Chapter6 재사용을 고려한 설계
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>

#include "save.h"

using namespace std;

// 게임 프로그래밍 패턴과 마찬가지로 일일이 적지 말고 중요한 부분이나 코드만 적는게 더 좋다 생각하여
// 그런 방식으로 바꾼다.


// 본인이 재사용 가능한 코드를 작성할 줄 알아야 한다.


// 재사용 철학
// - 작성은 한 번, 사용은 여러 번
// - 무슨 수를 쓰더라도 코드 중복은 피한다.
// - 같은 일을 반복하지 않는다.


// 코드를 재사용할 수 있도록 설계하는 방법
// 1. 용도나 분야가 약간 달라도 충분히 사용할 수 있도록 범용성을 갖춰야 한다.
// 2. 재사용 가능한 코드는 사용하기 쉽게 만들어야 한다.

// 재사용할 수 있는 코드를 설계하는 데 가장 중요한 부분은 추상화다.
// 추상화의 핵심 - 인터페이스와 구현을 실질적으로 분리하는데 있다.
// 코드작성자가 인터페이스를 변경하지 않고도 내부 구현 코드를 쉽게 수정할 수 있게 해준다.


// 추상화를 통해 재사용할 수 있는 코드를 설계할 때 두가지 주안점
// 1. 코드를 적절하게 구성해야 한다.
// 2. 여러분이 작성한 라이브러리나 코드의 기능을 사용하는 데 '진입점' 역할을 하는 인터페이스를 설계한다.


// 재사용에 최적화된 코드 구조화
// [1] 서로 관련 없거나 논리적으로 구분되는 개념을 합치지 않기 -> 단일책임원칙(SRT)
// - 프로그램을 서브시스템 단위로 논리적으로 나누기
// - 클래스 계층을 사용해서 논리적으로 나누기
/*
template <typename T>
class SelfDrivable : public T
{

};

SelfDrivable<Car> selfDrivableCar;
SelfDrivable<Truck> selfDrivableTruck;
*/
// - 집계 방식으로 논리적 개념 나누기(has-a)
// - 사용자 인터페이스에 대한 종속성 제거하기

// [2] 범용 데이터 구조와 알고리즘을 템플릿으로 구현하기
// - 템플릿이 다른 제네릭 프로그래밍 테크닉보다 낫다. -> 성능과 안전성을 더 갖췄다.
// - 템플릿의 단점 -> 문법이 복잡
// - 템플릿과 상속 -> 동일한 기능을 다양한 타입에 제공할때 -> 템플릿
//   특정 타입마다 동작을 다르게 제공할때 -> 상속


// [3] 적절한 검사 기능과 안전장치 제공하기
// 1. 계약에 따른 설계 - 선행조건, 후행조건, 불변조건 - 표준라이브러리에서 흔히 쓰인다.
// 2. 함수나 클래스를 최대한 안전하게 설계 -> 에러 검사 수행
// 이 두가지를 적절히 혼용


// [4] 확장성을 고려한 설계
// 개방/폐쇄 원칙(OCP) - 구현을 수정하지 않고도 동작을 확장할 수 있어야 한다.

class Shape {
public:
	virtual void render() = 0;
};

class Square : public Shape {
public:
	virtual void render() override { /* 사각형을 렌더링한다. */ }
	// 다른 멤버는 생략한다.
};

class Circle : public Shape {
public:
	void render() override {/* 원을 렌더링한다.*/ }
	// 다른 멤버는 생략한다.
};

class Renderer {
public:
	void render(const vector<Shape*>& objects) {
		for (auto& object : objects) { object->render(); }
	}
};



// 사용성 높은 인터페이스 설계
// [1] 사용자 고려하기
// [2] 용도 고려하기
// - API - 제품의 기능을 다양한 용도로 활용하거나 그 제품의 기능을 확장하기 위해 외부에 제공하는 인터페이스
// - 유틸리티 클래스와 라이브러리 - 범용성
// - 서브시스템 인터페이스 - 인터페이스와 구현을 명확히 분리 -> 모형성, 유연성
// - 컴포넌트 인터페이스 

// [3] 인터페이스를 사용하기 쉽게 설계하기
// - 익숙한 방식 따르기
// - 필요한 기능 빼먹지 않기
//   1. 클라이언트가 필요로 하는 동작을 모두 인터페이스에 추가하는 것이다.
//   2. 인터페이스에 최대한 많은 기능을 구현하는 것이다.
// - 군더더기 없는 인터페이스 제공하기
// - 문서와 주석 제공하기
//   1. 인터페이스 코드안에 주석
//   2. 별도로 문서제공

// [4] 범용 인터페이스 설계
// - 하나의 기능을 다양한 방식으로 실행하게 만들기
// - 커스터마이즈 지원하기 -> 인터페이스의 유연성을 높인다.

// [5] 범용성과 사용성의 조화
// - 인터페이스 분리 원칙(ISP) - 인터페이스의 복잡도를 낮추기 위해 인터페이스를 다양하게 제공


// 솔리드 원칙
// S - 단일 책임 원칙(SRP)
// O - 개방/폐쇄 원칙(OCP)
// L - 리스코프 치환 원칙(LSP)
// I - 인터페이스 분리 원칙(ISP)
// D - 의존성 역전 원칙(DIP)


int main()
{
	

	save("helloworld.cpp");
}


// Chapter6 재사용을 고려한 설계 完
