


================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이번에는 객체 개념을 설계에 적용하는 방법을 알아보자.
// 코드를 작성할 때 객체를 단순히 이용할 줄만 아는 프로그래머와 객체지향 프로그래밍의 개념을
// 제대로 이해하는 프로그래머의 차이는 객체 사이의 관계를 설정하는 방식뿐만 아니라 프로그램의 전반적인 설계를 보면 뚜렷하게 드러난다.

// 절차형 프로그래밍과 객체지향 프로그래밍은 프로그램의 실행 과정을 표현한 방식만 다르다는 점을 명심한다.
// 이 장에서는 코드보다는 개념을 중심으로 소개한다. C++의 객체지향 프로그래밍 관련 문법은 8장부터 시작한다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.1 절차형 사고방식
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이번에는 객체 개념을 설계에 적용하는 방법을 알아보자.
// 코드를 작성할 때 객체를 단순히 이용할 줄만 아는 프로그래머와 객체지향 프로그래밍의 개념을
// 제대로 이해하는 프로그래머의 차이는 객체 사이의 관계를 설정하는 방식뿐만 아니라 프로그램의 전반적인 설계를 보면 뚜렷하게 드러난다.

// 절차형 프로그래밍과 객체지향 프로그래밍은 프로그램의 실행 과정을 표현한 방식만 다르다는 점을 명심한다.
// 이 장에서는 코드보다는 개념을 중심으로 소개한다. C++의 객체지향 프로그래밍 관련 문법은 8장부터 시작한다.


// C와 같은 절차형 언어는 단 하나의 작업만 담당하는 프로시저라 부르는 작은 단위로 코드를 구성한다.
// 프로시저는 프로그래머가 코드를 읽고 관리하기 쉽도록 추상화한 것이다.
// 프로시저는 프로그램이 하는 일을 중심으로 만든 개념이다.

// 절차형 접근 방식은 일정한 단계에 따라 진행하는 프로그램에 적합하다. 반면 최신 대규모 에플리케이션에서는
// 여러 이벤트가 일정한 순서 없이 발생한다. 또한 사용자가 언제든지 원하는 명령을 수행할 수도 있다.
// 반면 절차형 접근 방식에서는 데이터의 표현 방식을 우선시하지 않는다.

// 절차형 사고방식에만 익숙하더라도 걱정할 필요 없다. 객체지향 프로그래밍은 소프트웨어를 보다 유연하게 표현하는
// 수단이라는 점만 이해하면 쉽게 익힐 수 있다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이번에는 객체 개념을 설계에 적용하는 방법을 알아보자.
// 코드를 작성할 때 객체를 단순히 이용할 줄만 아는 프로그래머와 객체지향 프로그래밍의 개념을
// 제대로 이해하는 프로그래머의 차이는 객체 사이의 관계를 설정하는 방식뿐만 아니라 프로그램의 전반적인 설계를 보면 뚜렷하게 드러난다.

// 절차형 프로그래밍과 객체지향 프로그래밍은 프로그램의 실행 과정을 표현한 방식만 다르다는 점을 명심한다.
// 이 장에서는 코드보다는 개념을 중심으로 소개한다. C++의 객체지향 프로그래밍 관련 문법은 8장부터 시작한다.


// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.




int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
// 5.2.1 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.


// 클래스란 개념을 적용하면 구체적인 대상과 그 대상에 대한 정의를 구분할 수 있다. 예를 들어 오렌지를 생각해보자.
// 나무에서 맛있는 과일로서 오렌지를 말할 때와 내가 먹고 있는 오렌지를 가리킬 때는 그 의미가 엄연히 다르다.

// 누가 '오렌지가 뭐냐'고 물어보면 오렌지는 나무에서 자라고 주황색을 띄고 독특한 향과 맛을 내는 과일의 한 종류(클래스)라고 답할 수 있다.
// 이처럼 클래스는 어떤 대상의 유형을 정의하는 속성을 정리한 것이다.

// 반면 어떤 특정한 오렌지를 가리킬 때는 구체적인 대상(객체)을 의미한다. 모든 객체는 특정 클래스에 속한다.

// 객체는 어떤 클래스에 속하는 구체적인 예(인스턴스)라고도 볼 수 있다. 다시 말해 같은 클래스에 속한 객체끼리도 나름 구분되는 특징이 있다.



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
// 5.2.2 컴포넌트
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.


// 비행기처럼 현실에 존재하는 복잡한 대상도 작은 부품(컴포넌트)으로 구성되어 있다.
// 비행기는 동체와 제어판, 랜딩기어, 엔진을 비롯한 수많은 요소로 구성된다.
// 절차형 프로그래밍에서 복잡한 작업을 프로시저(절차)라는 작은 단위로 쪼개는 것이 중요한 것처럼 OOP에서는 객체를 작은
// 컴포넌트 단위로 나누는 사고방식이 굉장히 중요하다.

// 컴포넌트는 본질적으로 클래스와 같다. 클래스보다 작고 구체적이라는 점만 다르다. OOP 방식을 제대로 적용했다면
// Airplane이란 클래스가 있을 것이다. 하지만 Airplane 클래스에 비행기의 모든 부분을 다 표현하면 클래스가 너무 커지게 된다.
// 그러므로 Airplane 클래스를 작고 관리하기 쉬운 컴포넌트 단위로 나눈다. 각각의 컴포넌트는 좀 더 세분화해서 하위 컴포넌트를
// 구성할 수 있다. 예를 들어 랜딩기어는 비행기의 컴포넌트이면서 동시에 바퀴라는 하위 컴포넌트를 가진다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
// 5.2.3 속성
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.


// 객체는 속성(프로퍼티)으로 구분한다. 앞에서 '오렌지' 클래스를 설명할 때 주황색을 띠고 독특한 맛을 내는 과일을 오렌지 클래스로 정의했다.
// 여기서 주황색과 독특한 맛이란 두 가지 특징이 바로 속성이다. 오렌지를 구성하는 속성의 종류는 같지만 그 값은 다르다.

// 속성을 클래스 관점에서 볼 수도 있다. 앞서 설명한 바와 같이 오렌지란 일종의 과일이고 모두 나무에서 자란다.
// 이러한 속성은 '과일' 클래스에도 있지만 오렌지가 가지는 독특한 주황색이란 속성은 다른 과일 객체와 구분되는 속성이다.
// 속성은 객체의 특성을 표현한다. 다시 말해 속성으로 객체끼리 구분할 수 있다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
// 5.2.4 동작
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.


// 동작(행위)은 객체가 직접 하거나 그 객체로 할 수 있는 일을 표현한다. 오렌지의 경우 직접 하는 일은 별로 없지만,
// 오렌지로 할 수 있는 일은 많다. 대표적인 예로 '먹기'가 있다. 속성과 마찬가치로 동작도 클래스 관점과 객체 관점으로 구분된다.
// 오렌지를 먹는 방식은 서로 비슷하지만 경사면에 굴려보면 완벽히 둥근 오렌지와 납작한 오렌지의 동작이 다르다.

// OOP에서는 어떤 기능을 수행하는 코드를 프로시저가 아닌 클래스 단위로 묶는다.
// 클래스가 여러 가지 동작을 수행하고, 서로 상호 작용하는 방식을 정의함으로써 데이터를 조작하는 코드를 훨씬 다양하게 제공할 수 있다.
// 이러한 클래스의 동작은 메서드로 구현한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.2 객체지향 철학
// 5.2.5 중간 정리
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 절차형 접근 방식은 '프로그램이 하는 일'을 중심으로 접근하는데 반해 객체지향 접근 방식은
// '모델링하려는 현실 세계의 대상'이라는 관점에서 접근한다. 객체지향 프로그래밍에서는 프로그램을 작업 단위가 아니라
// 실제 대상에 대한 모델 단위로 구성한다.


// 지금까지 설명한 개념을 바탕으로 주식종목 추천 프로그램을 OOP방식으로 설계해보자

// '주식시세'에 대한 클래스를 먼저 정의한다. 시세 정보를 수집하려면 각각의 주식시세를 그룹 단위로 묶어야 한다.
// 이를 흔히 컬렉션이라 부른다. 따라서 제대로 설계하려면 '주식시세 컬렉션'을 표현하는 클래스를 먼저 정의하고,
// 그 안에 한 종목의 '주식시세'를 표현하는 작은 컴포넌트를 담는다.

// 다음으로 속성을 정의한다. 주식시세 컬렉션 클래스에는 최소한 '수집한 시세 목록'이란 속성이 있어야 한다.
// 가장 최근에 조회한 날짜와 시각에 대한 속성도 있으면 좋다. 그리고 '주식시세 컬렉션'이 서버와 통신해서
// 시세 정보를 가져와서 정렬된 리스트로 제공하는 동작을 제공한다. 여기서 '시세 정보 가져오기', '시세 정보 정렬하기'가 동작이다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.3 클래스 세상에 살기
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 소프트웨어를 클래스 관점을 개발하는 데 적용할 수 있는 접근 방식은 크게 두 가지가 있다.
// 하나는 클래스를 단순히 데이터와 기능을 잘 묶어주는 수단으로만 여기고 프로그램 전반에 걸쳐 사용해서 가동성과 유지 보수성을 높이는 것이다.
// 또 다른 방식은 OOP 패러다임을 완벽히 적용해서 처음부터 모든 것을 클래스로 표현하는 것이다.

// 가장 바람직한 방법은 이러한 두 가지 접근 방식을 적절히 조합하는 것이다. OOP 방식을 처음 적용할 때는
// 절차형 프로그램에 클래스가 가미된 것처럼 보일 수 있다. 아니면 반대로 극단적으로 OOP를 추구해서 메인 애플리케이션뿐만 아니라
// int 마저도 클래스로 표현해버릴 수 있다. 결국 경험이 쌓이다 보면 적절한 타협점을 찾게 된다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.3 클래스 세상에 살기
// 5.3.1 과도한 클래스화
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 소프트웨어를 클래스 관점을 개발하는 데 적용할 수 있는 접근 방식은 크게 두 가지가 있다.
// 하나는 클래스를 단순히 데이터와 기능을 잘 묶어주는 수단으로만 여기고 프로그램 전반에 걸쳐 사용해서 가동성과 유지 보수성을 높이는 것이다.
// 또 다른 방식은 OOP 패러다임을 완벽히 적용해서 처음부터 모든 것을 클래스로 표현하는 것이다.

// 가장 바람직한 방법은 이러한 두 가지 접근 방식을 적절히 조합하는 것이다. OOP 방식을 처음 적용할 때는
// 절차형 프로그램에 클래스가 가미된 것처럼 보일 수 있다. 아니면 반대로 극단적으로 OOP를 추구해서 메인 애플리케이션뿐만 아니라
// int 마저도 클래스로 표현해버릴 수 있다. 결국 경험이 쌓이다 보면 적절한 타협점을 찾게 된다.


// 객체지향 시스템을 창의적으로 설계하는 것과 사소한 것까지 클래스로 만들어 팀원들을 불편하게 만드는 것은 분명 다르다.

// 물론 절대적인 정답은 없다. 핵심은 애플리케이션을 설계할 때 여러 고민을 반드시 거쳐야 한다는 것이다.
// 클래스는 어디까지나 프로그래머가 코드를 관리하는데 도움을 주기 위한 것임을 명심한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.3 클래스 세상에 살기
// 5.3.2 지나치게 일반화한 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 소프트웨어를 클래스 관점을 개발하는 데 적용할 수 있는 접근 방식은 크게 두 가지가 있다.
// 하나는 클래스를 단순히 데이터와 기능을 잘 묶어주는 수단으로만 여기고 프로그램 전반에 걸쳐 사용해서 가동성과 유지 보수성을 높이는 것이다.
// 또 다른 방식은 OOP 패러다임을 완벽히 적용해서 처음부터 모든 것을 클래스로 표현하는 것이다.

// 가장 바람직한 방법은 이러한 두 가지 접근 방식을 적절히 조합하는 것이다. OOP 방식을 처음 적용할 때는
// 절차형 프로그램에 클래스가 가미된 것처럼 보일 수 있다. 아니면 반대로 극단적으로 OOP를 추구해서 메인 애플리케이션뿐만 아니라
// int 마저도 클래스로 표현해버릴 수 있다. 결국 경험이 쌓이다 보면 적절한 타협점을 찾게 된다.


// 클래스로 정의할 필요가 없는 것까지 클래스로 만드는 것보다 더 나쁜 것은 클래스를 지나치게 일반화하는 것이다.
// 실전에서 다루는 클래스는 다소 추상적이다. 클래스를 과도하게 일반화하면 구체적인 대상을 표현하기 힘들다.
// 예로 미디어를 구성하는 프로그램이 나오는데 너무 길어 넘어간다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.1 has-a 관계
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.

// A는 B를 가진다 혹은 A에 B가 있다고 표현되는 클래스 관계를 has-a 관계(집계 관계, 포함 관계, 소유 관계)라 한다.
// 한 클래스가 다른 클래스의 일부라고 상상하면 이해하기 쉽다. 앞서 정의한 컴포넌트는 다른 클래스로 구성된 클래스를 설명하므로
// 일반적으로 has-a 관계로 나타낸다. has-a 관계에 대한 현실 세계의 예로 동물원과 원숭이의 관계를 들 수 있다.

// 클래스 관계는 사용자 인터페이스를 살펴보면 이해하기 쉽다. UI를 완전히 OOP로 구현하지 않더라도 화면에 나타나는
// 시각적인 요소를 클래스로 표현하는 것은 어렵지 않다. UI에서 볼 수 있는 has-a 관계에 대한 대표적인 예로 버튼을 가진 창을 들 수 있다.

// ---------------------------------------------------------------------
// NotePad
// Do you want to save changes to Untitled?
//					Save     Don't save    Cancel
// ----------------------------------------------------------------------

// has-a 관계에는 두 가지 유형이 있다.
// - 집계(aggregation) : 집계된 객체(컴포넌트)는 집계를 수행한 대상이 제거되더라도 남아 있다
//	예를 들어 동물원 객체는 여러 동물 객체로 구성되어 있는데, 동물원 객체가 사라지더라도 동물 객체는 사라지지않고,
//  다른 동물원으로 옮겨질 것이다.
// - 합성(composition) : 여러 객체로 구성된 객체가 제거되면 포함된 객체도 함께 사라진다.
//  예를 들어 여러 버튼이 담긴 창 객체가 제거되면 그 안에 담긴 버튼 객체도 함께 제거된다.						
//



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.2 is-a 관계(상속)
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// is-a 관계는 OOP의 핵심 개념이다. 그러므로 파생, 서브클래싱, 확장, 상속등으로 다양하게 표현한다.
// 클래스는 현실 세계가 여러 가지 속성과 동작을 가진 객체로 구성된다는 점에 근거를 두고 모델링하는 것이고,
// 상속은 이러한 객체가 주로 계층 구조를 형성한다는 관점에서 모델링하는 것이다.

// 기본적으로 상속은 'A는 일종의 B다' 또는 'A는 B를 상당히 많이 닮았다'로 표현한다.
// --------------------------------------------------------------------------
//									동물
//                                   |
//    -------------------------------------------------------------- 
//    |             |                             |                |
//  원숭이         기린                          캥거루            펭귄

// 클래스를 is-a 관계로 엮으려면 공통 기능을 베이스 클래스(상위 클래스)로 묶어서 다른 클래스가 확장할 수 있게 만들어야 한다.
// 여러 클래스의 코드가 상당 부분 겹치거나 완전히 똑같다면 그 부분을 상위 클래스로 묶어서 빼내는게 좋다.
// 그래야 공통적인 부분에서 변경사항이 발생할 때 상위 클래스만 고쳐도 다른 하위 클래스에 수정사항을 똑같이 반영할 수 있다.


// [1] 상속 기법
// 다른 클래스를 상속한 파생(하위) 클래스를 부모 클래스(상위)와 구분하는 몇 가지 방법이 있다.
// 파생 클래스는 이러한 기법들 중 한 개 혹은 여러 개를 조합해서 만든다.

// 기능 추가
// 파생 클래스는 기능을 더 추가해서 부모 클래스를 확장할 수 있다. 예를 들어 원숭이는 일종의 동물로서 나무에 매달릴 수 있다.
// 원숭이 클래스는 원숭이 클래스만 가지고 있는 swingFromTrees()라는 메서드가 있다.

// 기능 변경
// 파생 클래스는 부모 클래스가 가진 메서드를 변경하거나 무시(오버라이드)할 수 있다.
// 물론 상위 클래스에 있는 속성과 메서드를 모두 바꿔야 한다는 것은 상위 클래스가 추상 클래스가 아닌 이상 에초에
// 설계가 잘못되었다는 뜻이다. 베이스 클래스를 추상 클래스로 정의하면 이를 상속하는 모든 파생 클래스는 베이스 클래스에 구현되지 않은
// 모든 메서드를 모두 구현해야 한다.

// 속성 추가
// 베이스 클래스르 상속한 파생 클래스는 새로운 속성을 추가할 수도 있다. 예를 들어 펭귄은 동물이 가진
// 모든 속성과 더불어 부리 크기란 속성도 가진다.

// 속성 변경
// C++는 메서드를 오버라이드하는 것처럼 속성도 오버라이드할 수 있다. 하지만 이렇게 하는 것이 바람직하지 않을 때가 많다.
// 베이스 클래스의 속성을 가리기 때문이다.


// [2] 다형성
// 다형성(폴리모피즘)이란 일정한 속성과 메서드를 표준으로 정해두면
// 그 형식에 맞는 객체라면 어느 것이든 서로 바꿔서 적용할 수 있다는 개념이다.
// 클래스 정의는 객체와 그 객체를 다루는 코드가 서로 맺는 계약과 같다. 
// 따라서 모든 Monkey 객체는 Monkey 클래스에 정의된 속성과 메서드를 반드시 제공해야 한다.

// 다형성은 OOP에서 가장 멋진 부분이다. 상속이 제공하는 장점을 제대로 살리기 때문이다. 동물원 예에서
// 동물원에 있는 모든 동물에 대해 루프를 돌며 각각을 한 번씩 움직인다고 생각해보자.
// 모든 동물은 Animal 클래스에 속하기 때문에 각자 이동이란 동작을 수행할 수 있다. 어떤 동물은
// 이동하는 동작에 대한 move 메서드를 오버라이드했을 수도 있는데, 이때 바로 다형성의 진가가 발휘된다.
// 즉, 구체적인 동물의 종류를 따질 필요 없이 그냥 move 메서드만 실행하는 방식으로 모든 동물을 이동시킬 수 있다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.3 has-a 관계와 is-a 관계 구분하기
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// 현실에서는 객체에 대한 has-a 관계와 is-a 관계를 쉽게 구분할 수 있다. 오렌지는 과일의 한 종류임이 당연해서(is-a),
// 오렌지가 과일을 가진다고(has-a) 주장하는 사람은 없을 것이다. 하지만 프로그래밍 세계에서는 이 관계가 분명하지 않을 때가 많다.

// 키와 값을 효울적으로 매핑하는 데이터 구조인 연관 배열을 표현하는 클래스를 생각해보자.
// 예를 들어 보험회사에서 사용자 ID만으로 간편히 이름을 검색하고 싶다면 ID와 이름을 매핑하는 AssciativeArray 클래스를 만들면 된다.
// 이때 사용자 ID가 키이고, 이름은 값이다.

// ID가 14534인 키가 '스콧 클래퍼'란 이름에 매핑되어 있다면 같은 키로 '마르니 클래퍼'란 이름에는 매핑할 수 없다.
// 이미 값이 지정된 키에 또 다른 값을 추가하면 기존 값을 덮어쓰도록 구현하는 경우가 많다.
// 다시말해 ID 14534에 '스콧 플래퍼'가 매핑된 상태에서 같은 ID의 값을 '마르니 클래퍼'로 할당하면 '스콧 플랫퍼'에 대한
// 정보를 삭제하는 효과가 발생한다.
/*
myArray.insert(14534, "스콧 클래퍼");
// 키            값
// 14534     스콧 크래퍼

myArray.insert(14534, "마르니 클래퍼");
// 키            값
// 14534     마르니 클래퍼

// 연관 배열과 비슷하면서 키 하나에 여러 값을 매핑할 수 있는 데이터 구조를 얼마든지 만들 수 있다.
Collection collection;							// 컬렉션을 새로 만들다.
collection.insert("스콧 플래퍼");				// 컬렉션에 새 항목을 추가한다.
myArray.insert(14534, collection);				// 이 컬렉션을 테이블에 추가한다.
// 키            값
// 14534     스콧 크래퍼
Collection collection = myArray.get(14534);		// 앞서 저장한 컬렉션을 가져온다.
collection.insert("마르니 플래퍼");				// 이 컬렉션에 새 항목을 추가한다.
myArray.insert(14534, collection);				// 수정된 컬렉션을 테이블에 반영한다.
// 키            값
// 14534     마르니 클래퍼
*/

// 스트링 대신 컬렉션 타입으로 값을 다루다 보면 중복되는 코드가 많아지고 작업이 번거로울 수 있다.
// 따라서 이렇게 여러 값을 저장하는 기능을 MultiAssociativeArray란 이름의 클래스로 빼내면 좋다.
// MultiAssociativeArray 클래스는 키에 대한 값을 스트링 하나가 아닌 여러 스트링에 대한 컬렉션으로 저장한다.
// MultiAssociativeArray는 데이터를 저장할 때 연관 배열을 사용한다는 점에서 분명히 AssciativeArray와 관련 있다.
// 하지만 그 관계를 is-a로 구현해야 하는가 has-a로 구현해야 바람직한가?

// 사실 어느 하나가 뚜렷이 낫다고 말하기 힘들다.
// 각각의 이유를 정리하면 다음 표와 같다.
// ----------------------------------------------------------------------
//          is-a                                                        has-a
//지지이유: 속성만 다를 뿐 추상화 방식은 근본적으로 같다.        MultiAssociativeArray는 AssciativeArray에서 제공하는 메서드에
//                                                           구애받지 않고 마음껏 원하는 메서드를 추가할 수 있다.
// 
// 
// 반대이유: 연관 배열의 정의에 따르면 반드시 키 하나에 값도      MultiAssociativeArray는 메서드만 새로 고칠 뿐 실질적으로는
//			하나만 가져야 한다. 따라서 MultiAssociativeArray는  기존에 있는 것을 다시 만드는 것이다.
//          연관 배열이라 볼 수 없다.
// ----------------------------------------------------------------------

// 위 표를 보면 이 경우에는 is-a를 반대하는 이유가 꽤 설득력 있다. 이때 '동작을 바꾸지 않고도
// 베이스 클래스 대신 파생 클래스를 사용할 수 있어야 한다'는 LSP(리스코프 치환 원칙)를 적용하면 is-a 관계와 has-a 관계를
// 쉽게 구분할 수 잇다. 이 원치긍ㄹ 적용하면 has-a관계로 봐야한다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.4 not-a 관계
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// 두 클래스 관계 중 어느 것이 적합한지 따지기 전에 먼저 그런 관계가 성립할 수 있는지부터 살펴봐야 한다

// 객체지향 방식으로 계층을 구성하려면 억지로 관계를 형성하지 말고 기능 관점에서 관계를 표현해야 한다.
// 계층이나 존재론의 관점에서에만 의미있는 것은 코드에서는 중요하지 않다.

// 이렇게 불필요한 상속 관계를 만들지 않으려면 먼저 설계 초안부터 그려보면 좋다.
// 모든 클래스와 파생 클래스마다 어떤 속성과 메서드를 넣으면 좋을지 적는다.
// 특별히 속성이나 메서드를 갖지 않는 클래스가 있거나 추상 베이스가 클래스가 아닌 클래스의 속성과 메서드를
// 다른 파생 클래스에서 모두 오버라이드한다면 설계를 바꾸는 것이 좋다.



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.5 클래스 계층
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// A 클래스가 B 클래스의 베이스 클래스가 될 수 있듯이 B 클래스도 C 클래스의 베이스 클래스가 될 수 있다.
// 객체지향 계층은 클래스 관계를 이렇게 여러 계층으로 표현한다.
// ------------------------------------------------------------------------------
//							Animal
//							  |
//   ------------------------------------------------------------
//   |              |                        |                  |
// Monkey         Giraffe                 Kangaroo            Penguin
//

// 각 파생 클래스를 구현하다 보면 여러 가지 공통점을 발견할 수 있다.그렇다면 이런 부분은 부모 클래스로 옮기는 게 좋다.
// 사자와 표범의 이동 방식과 먹이가 같다면 Lion 클래스와 Panther 클래스를 포괄하는 BigCat 클래스를 만드는 것이 바람직하다.

// 한가지 명심할 점은 계층을 얼마든지 다르게 구성할 수 있다는 것이다.
// 핵심은 클래스의 활용 방법에 있다. 구체적인 요구사항에 따라 객체 계층을 설계한다.

// 제대로 구성된 객체지향 계층은 다음과 같은 특성을 갖는다.
// - 기능적으로 의미 있는 관계에 따라 클래스를 구성한다.
// - 공통 기능을 베이스 클래스로 뽑아냈기 때문에 코드를 재활용하기 쉽다.
// - 부모가 추상 클래스가 아닌 이상 부모의 기능을 과도하게 오버라이딩하는 파생 클래스가 없다.



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.6 다중 상속
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// 지금까지 살펴본 예제는 모두 단일 상속으로 구성했다. 다시 말해 파생 클래스의 바로 위 부모 클래스는 하나 뿐이다.
// 그런데 반드시 이렇게 할 필요는 없다. 다중 상속을 통해 베이스 클래스를 여러 개 둘 수 있다.

// 다중 상속이 꼭 필요할 때가 있긴 하지만 단점도 많기 때문에 사용할 때 각별히 주의해야 한다.
// 다중 상속을 반대하는 이유는 다음과 같이 여러 가지가 있다.
// 1. 다중 상속 관계는 시각적으로 표현하기 복잡하다.
// 2. 다중 상속 때문에 구조의 명확성이 깨질 수 있다.
// 3. 다중 상속은 구현하기 힘들다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.4 클래스 관계
// 5.4.7 믹스인 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 프로그래밍을 하다 보면 서로 다른 클래스가 공통적이 속성을 가지거나, 최소한 두 개가 서로 관련된 경우가 있다.
// 객체지향 언어는 이러한 클래스 사이의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.
// 하지만 클래스 관계를 정확히 파악하기 쉽지 않다. 클래스 관계에는 has-a 관계와 is-a 관계 두 가지가 있다.


// 믹스인 클래스(mixin class(첨가 클래스))는 지금까지 소개한 것과 다른 종류의 클래스 관계를 표현한다.
// C++에서 믹스인의 문법은 다중 상속과 같지만 의미는 전혀 다르다.
// 믹스인 클래스는 '이 클래스가 할 수 있는 일이 또 뭐가 있나?'라는 질문에 '~도 할 수 있다'라는 답을 제시한다.
// 믹스인 클래스는 is-a 관계를 완전히 구현하지 않고도 기능을 추가할 때 사용된다. 일종의 공유관계라고 볼 수 있다.

// 믹스인 클래스는 사용자 인터페이스 코드에서 흔히 볼 수 있다. PictureButton 클래스가 모두 Image와 Button을 상속한다고
// 표현하는 대신 클릭할 수 있는 Image라고 표현할 수 있다.

// 믹스인 클래스와 베이스 클래스의 차이점은 코드보다는 생각하는 방식에 있다. 일반적으로 믹스인 클래스는
// 상당히 제한적인 용도로만 사용하기 때문에 다중 상속보다 이해하기 훨씬 쉽다. 또한 믹스인 클래스는 거대한
// 계층 구조를 형성할 일이 드물어서 기능이 서로 충돌할 가능성도 낮다. 믹스인 클래스는 자웅에 자세히 소개한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.5 정리
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;

// 이 장에서는 OOP 설계에 대한 개념을 최소한의 코드 예제만으로 살펴봣다.
// 여기서 배운 개념은 거의 모든 객체지향 언어에 적용할 수 있다.

// 객체지향 프로그래밍을 처음 해보거나, 경험이 많지 않더라도 이 장에서 설명한 내용을
// 이해했다면 OOP 설계 방법에 대해 경험이 풍부한 C++프로그래머보다 더 많은 것을 알고 있는 셈이다.

// 객체 사이의 관계는 반드시 이해하고 넘어가야 한다.
// 객체 사이의 관계를 잘 설정하면 단순히 코드의 재활용성이나 간결성에 도움이 될 뿐만 아니라 팀 단위로 협업을 하는 데도 도움이 된다.
// 의미가 잘 반영된 객체 관계는 이해하기도 쉽고 유지 보수하기도 편하다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.6 연습 문제
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;



int main()
{
	

	save("helloworld.cpp");
}


// Chapter5 객체지향 설계 完================================================




================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.10 공부
// Chapter5 객체지향 설계
// 5.6 연습 문제
/////////////////////////////////////////////////////////////////

#include <iostream>


#include "save.h"

using namespace std;



int main()
{
	

	save("helloworld.cpp");
}


// Chapter5 객체지향 설계 完================================================
