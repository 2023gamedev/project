


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.26 공부
// Chapter8 라이브러리 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 기존 라이브러리 최적화 - 기존 라이브러리를 최적화하는 작업은 지뢰밭에서 지뢰를 제거하는 작업과 같습니다.
// - 가능한 한 적게 수정하세요
// - 기능을 변경하기 보다는 추가하세요



// 최적화된 라이브러리 설계
// - 서둘러 코딩하면 두고두고 후회합니다.
//   - 인터페이스의 안정성은 라이브러리의 핵심 산출물입니다.
//   - 라이브러리를 설계하는 것은 다른 C++코드를 설계하는 것과 같습니다. 다만 더 위험할 뿐입니다.
// - 절약은 라이브러리 설계의 덕목입니다. -> 여기서 절약은 특정 작업에 초점을 맞추고 해당 작업 수행에 필요한
//                                         최소한의 기능만을 포함하는 라이브러리를 의미합니다.
// - 라이브러리 바깥에서 메모리 할당을 결정하세요
// - 확신이 서지 않으면 속도를 위한 라이브러리 코드르 작성하세요
// - 함수가 프레임워크보다 최적화하기 쉽습니다.
// - 상속 계층 구조를 평평하게 만드세요
// - 호출 체인을 평평하게 만드세요
// - 계층화된 설계를 평평하게 만드세요
// - 동적 검색을 피하세요
// - '신의 함수'를 조심하세요 -> '신의 함수'는 프로그램에서 사용할 때 링커가 더 많은 라이브러리 함수를 실행 파일에
//                              추가하도록 하는 고수준 전략을 구현하는 함수입니다.


// 정리
// - 함수와 클래스는 다른 방법으로 제공할 수 없거나 여러 운영체제어서 매우 광범위하게 재사용할 수 있기에 C++
//   표준 라이브러리에 들어가 있습니다.
// - 표준 라이브러리의 구현에 버그가 있습니다.
// - '표준을 준수하는 구현'같은 것은 없습니다.
// - 표준 라이브러리는 운영체제의 가장 좋은 네이티브 함수만큼 효율적이지 않습니다.
// - 라이브러리를 갱신할 때 가능한 한 적게 수정하세요.
// - 인터페이스의 안정성은 라이브러리의 핵심 산출물입니다.
// - 테스트 케이스는 라이브러리 최적화에 중요합니다.
// - 라이브러리를 설계하는 것은 다른 C++코드를 설계하는 것과 같습니다. 다만 더 위험할 뿐입니다.
// - 추상화에서 클래스의 파생 계층은 대부분 3계층 이하여야 합니다.
// - 추상화 구현에서 함수 호출은 대부분 중첩 횟수가 3회 이하여야 합니다.




int main()
{
    save("Optimized C++study.cpp");
}

// Chapter8 라이브러리 최적화 完================================================
