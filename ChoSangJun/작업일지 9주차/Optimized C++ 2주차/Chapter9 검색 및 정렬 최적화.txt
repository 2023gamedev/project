


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.26 공부
// Chapter9 검색 및 정렬 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// C++ 프로그램은 검색을 많이 합니다.


// std::map

// 검색 성능 향상을 위한 툴킷
//void HotFunction(std::string const& key) {
//
//    auto it = table.find(key);
//    if (it == table.end()) {
//        /// 테이블에 항목이 없을 때의 작동
//    }
//    else {
//        // 테이블에 항목이 있을 때의 작동
//    }
//}

// - 기존 구현 코드의 성능을 측정하고 비교하기 위한 기준치를 얻습니다.
// - 최적화할 추상화 코드를 구현합니다.
// - 최적화할 코드를 알고리즘과 자료구조로 분해합니다.
// - 최적이 아닌 알고리즘과 자료구조를 변경하거나 바꿉니다. 그리고 변경한 코드가 효과적인지 확인하기 위해 실험합니다.

// - 측정 기준치를 만드세요
// - 최적화할 코드를 확인하세요
// - 최적화할 코드를 분해하세요
// - 알고리즘과 자료구조를 변경하거나 바꾸세요
// - 사용자 정의 추상화에 최적화 과정 사용하기


// std::map을 사용한 검색 최적화
// - std::map에 고정된 크기를 갖는 문자열 키를 사용하세요
// - std::map에 C 스타일 문자열 키를 사용하세요
// - 키가 값에 있을 때 맵의 사촌인 std::set을 사용하기

// <algorithm> 헤더를 사용한 검색 최적화
// - 시퀀스 컨테이너의 검색을 위한 키/값 테이블
// - 이름이 명확하고 시간 비용이 O(n)인 std::find
// - 값을 반환하지 않는 std::binary_search()
// - std::equal_rande()를 사용한 이진 검색
// - std::lower_bound()를 사용한 이진 검색
// - 직접 코딩한 이진 검색
// - strcmp()를 사용해 직접 코딩한 이진 검색



// 정리
// - C++은 자동화와 표현력부터 성능 향상을 위한 세밀한 제어까지 다양한 기능 구현 옵션을 제공합니다.
//   바로 이러한 폭넓은 선택 가능성 덕분에 성능 요구 사항을 충족하기 위해 C++프로그램을 개선할 수 있습니다.
// - 사람들은 머릿속에 있는 내용을 기억하고 싶어 합니다. 하지만 모든 걸 확실하게 기억할 수는 없습니다.
//   종이에 기록하면 더 오랫동안 기억할 수 있습니다.
// - 26개의 키가 저장되어 있는 테이블로 검색 테스트를 지정했을 때 문자열 키를 사용하는 std::unordered_map은 문자열
//   키를 사용하는 std::map보다 단지 52% 빨랐습니다. 해싱이 굉장히 좋은 성능을 갖는다는 헛된 희망을 품었다는 점을 감안할 때
//   결과는 매우 놀라웠습니다.
// - 스테파노프의 추상화 패널티는 C++ 표준라이브러리의 알고리즘처럼 매우 생상적인 도구를 사용하기 위해 내는 통행료입니다.


int main()
{
    save("Optimized C++study.cpp");
}

// Chapter9 검색 및 정렬 최적화 完================================================
