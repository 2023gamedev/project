


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.25 공부
// Chapter5 알고리즘 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// O(n)에 관한 얘기

// 몇 초만에 실행되어야 하는 프로그램이 몇 시간이나 걸린다면, 여러분이 선택할 수 있는 최적화는
// 더 효율적인 알고리즘을 선택하는 것뿐입니다.


// 최적화 패턴
// - 사전 계산 : 프로그램 실행 초기나 링크 타임, 컴파일 타임, 디자인 타임에서 자주 사용하는 코드를 미리 계산해 최적화합니다.
// - 지연 계산 : 계산 코드를 실제로 필요한 부분과 최대한 가까운 곳으로 미뤄 최적화합니다.
// - 배칭      : 한번에 여러 항목을 계산해 최적화합니다.
// - 캐싱      : 계산 비용이 높은 코드의 결과를 저장한 뒤 재사용해 최적화합니다.
// - 특수화    : 사용하지 않는 일반화된 코드를 제거해 최적화합니다.
// - 더 큰 조각 선택하기 : 입력 데이터를 한번에 많이 가져와 반복작업을 줄여서 최적화합니다.
// - 힌팅      : 성능을 향상할 수 있는 힌트를 제공해 최적화합니다.
// - 예상 경로 최적화 : 발생할 가능성이 가장 낮은 입력이나 이벤트의 런타임부터 테스트해 최적화합니다.
// - 해싱      : 가변 길이를 갖는 문자열처럼, 크기가 큰 자료구조를 해시로 계산합니다. 해시는 자료구조를 대신에 성능을 향상시킬수 있습니다.
// - 이중 검사 : 비용이 크지 않은 검사를 수행하되, 비용이 큰 검사는 필요한 경우에만 수행해 최적화합니다.


// 정리
// - 누군가 상수 시간을 갖는 알고리즘을 홍보한다면 의심해봐야 합니다. 시간 비용이 O(n)일 수도 있습니다.
// - 효율적인 알고리즘을 여러 개 결합해서 사용하면 전체 실행 시간이 O(n^2)이상이 될 수 있습니다.
// - 이진 검색은 시간 비용이 O(log2n)이라 성능은 뛰어나지만 가장 빠른 검색 알고리즘은 아닙니다.
//   보간 검색의 시간 비용은 O(loglogn)이고 해싱의 시간 비용은 상수 시간입니다.
// - 항목이 4개 미만인 작은 테이블에서는 모든 검색 알고리즘이 검사하는 항목의 수가 거의 같습니다.


int main()
{
    save("Optimized C++study.cpp");
}

// Chapter5 알고리즘 최적화 完================================================
