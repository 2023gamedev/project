


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.27 공부
// Chapter12 동시성 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 동시성 - 여러 스레드를 동시에 실행하는 성질을 말합니다. 동시성의 목표는 명령어 실행 수나
//         데이터 워드 접근 횟수 자체를 줄이는 것이 아니라 자원을 최대한 활용해 전체 실행 시간을 줄이는 것입니다.


// 동시성 용어
// - 시분할: 운영체제에 있는 스케줄러의 기능
// - 가상화: 일반적인 유형의 가상화는 하이퍼바이저라고 하는 경량 운영체제가 프로세서의 사용 가능 시간을 게스트 가상 머신에 할당합니다.
//   가상화의 장점은 다음과 같습니다.
//   - 게스트 가상 머신은 실행 상태가 아닐 경우 디스크의 파일 형태로 존재합니다. 게스트 가상 머신은 여러 컴퓨터 호스트에서
//     체크포인트 지정 및 저장, 불러오기 및 재시작, 복사 및 실행을 할 수 있습니다.
//   - 자원이 충분히 있다면 동시에 여러 게스트 가상 머신을 실행 할 수 있습니다. 각 게스트 가상머신은 하이퍼바이저로 컴퓨터의
//     가상 메모리 하드웨어와 협력해 다른 가상 머신과 분리됩니다.
//   - 게스트 가상 머신은 호스트 컴퓨터의 자원 일부를 사용하도록 구성할 수 있습니다.
// - 컨테이너화: 컨테이너가 파일 시스템 이미지와 체크포인트된 프로그램 상태를 포함하는 메모리 이미지를 저장한다는 점에서 가상화와 비슷합니다.
//              하지만 컨테이너 호스트가 운영체제라는 점이 다릅니다.
// - 대칭적 멀티프로세서: 똑같은 기계 코드를 실행하고 동일한 물리 메모리에 접근하는 여러 실행 단위가 포함된 컴퓨터입니다.
// - 동시 멀티스레딩
// - 다중 프로세스
// - 분산처리: 서로 다른 일련의 프로세서에 작업을 분산하는 것입니다.
// - 스레드: 같은 메모리를 공유하는 프로세스 내동시적 실행 스트림을 말합니다.
// - 태스크: 별도의 스레드 콘텍스트에서 비동기적으로 호출될 수 있는 실행 단위를 말합니다.


// 교차 실행
// 순차적 일관성
// 경쟁상태
// 동기화
// 원자성


// C++ 동시성 기능
// - 스레드
//void f1(int n) {
//    std::cout << "thread " << n << std::endl;
//}
//
//void thread_example() {
//    std::thread t1;
//    t1 = std::thread(f1, 1);
//    t1.join();
//    std::thread t2(f1, 2);
//    std::thread t3(std::move(t2));
//    std::thread t4([]() {return; }); // 람다를 사용할 수도 있습니다.
//    t4.detach();
//    t3.join();
//}
//
//// - 프로미스와 퓨쳐 
//// C++의 템플릿 클래스인 std::promise와 std::future는 하나의 스레드에서 다른 스레드로 메시지를 보내고 받습니다.
//void promise_future_example() {
//    auto meaning = [](std::promise<int>& prom) {
//        prom.set_value(42); // 인생의 의미를 계산합니다.
//    };
//
//    std::promise<int> prom;
//    std::thread(meaning, std::ref(prom)).detach();
//
//    std::future<int> result = prom.get_future();
//    std::cout << "the meaning of life: " << result.get() << "\n";
//}
// - 비동기 태스크
// - 뮤텍스 -> 뮤텍스는 4종류의 뮤텍스 템플릿을 포함하고 있습니다.
//   - std::mutex
//   - std::recursive_mutex
//   - std::timed_mutex
//   - std::recursive_timed_mutex
// - 락
// - 조건변수
// - 공유 변수에 대한 원자적 연산
 



// 더 효율적인 동기화 만들기
// - 임계 구역의 범위 줄이기
// - 동시 스레드 수 제한하기
// - 놀란 양 떼 피하기 
// - 락 전달 피하기
// - 경쟁 상태 줄이기
// - 싱글 코어 시스템에서 바쁜 대기를 하지 마세요
// - 영원히 대기하지 마세요
// - 사용자 정의 뮤텍스 사용은 효과적이지 않을 수 있습니다.
// - 생산자 출력 큐의 길이 재현하기



// 정리
// - 멀티스레드 C++프로그램은 경쟁이 없는 경우 순차적으로 일관성이 있습니다.
// - 강경한 입장을 취하는 영향력 있는 일부 커뮤니티는 명시적인 동기화와 공유 변수가 나쁜 아이디어라고 생각합니다.
// - 임계 구역에서 I/O를 수행하면 최적의 성능을 이끌어내지 못합니다.
// - 실행 가능한 스레드 수는 프로세서의 코어 수보다 작거나 같아야 합니다.
// - 임계 구역을 짧게 만들기 위해 경쟁하는 스레드의 이상적인 개수는 2개입니다.






int main()
{
    save("Optimized C++study.cpp");
}

// Chapter12 동시성 최적화 完================================================
