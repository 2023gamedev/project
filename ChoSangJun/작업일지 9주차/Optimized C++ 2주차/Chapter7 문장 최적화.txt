


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.26 공부
// Chapter7 문장 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 문장 수준에서 이뤄지는 최적화는 프로그램을 실행할 때 불필요한 명령어를 제거하는 과정으로 비유할 수 있습니다.

// 사실 함수 호출을 제외한 문장에서 이뤄지는 최적화의 문제점은 C++의 명령어를 그다지 많이 사용하지 않는다는 것입니다.
// 한마디로 노력보다 성능을 개선한 결과는 미약합니다.

// 물론 개발자가 문장의 비용을 크게 만드는 요소를 최적화할 정도로 만드는 요소는 다음과 같은 것들이 있습니다.
// - 반복문
// - 자주 호출되는 함수
// - 프로그램 전체에서 사용되는 관용구


// 반복문에서 코드 제거하기
// - 반복문의 종룟값을 캐싱하세요
// - 더 효율적인 반복문을 사용하세요
// - 값을 증가하는 대신 감소하게 하세요
// - 반복문에서 불변 코드를 제거하세요
// - 반복문에서 불필요한 함수 호출을 제거하세요
// - 반복문에서 숨겨진 함수 호출을 제거하세요
//   - 클래스 인스턴스의 선언(생성자를 호출)
//   - 클래스 인스턴스의 초기화(생성자를 호출)
//   - 클래스 인스턴스의 대입(대입 연산자를 호출)
//   - 클래스 인스턴스를 포함하는 산술 표현식(연산자 멤버 함수를 호출)
//   - 범위를 빠져나갈 때(범위에서 선언된 클래스 인스턴스의 소멸자를 호출)
//   - 함수 인수(각 인수 표현식은 형식 인수로 복사 생성됨)
//   - 클래스 인스턴스의 함수 반환(아마도 복사 생성자를 두 번 호출)
//   - 표준 라이브러리 컨테이너에 항목을 삽입(항목이 이동 또는 복사 생성됨)
//   - 벡터에 항목을 삽입(벡터가 재할당될 경우 모든 항목이 이동 또는 복사 생성됨)
// - 반복문에서 비용이 크고 변화가 느린 호출을 제거하세요.
// - 반복문을 함수 안에 넣어 호출 오버헤드를 줄이세요.
// - 어떤 행동을 하는 횟수를 줄이세요.



// 함수 호출 비용
// 1. 실행 코드는 함수의 인수와 지역 변수를 저장하기 위해 호출 스택에 새 프레임을 삽입합니다.
// 2. 각 인수 표현식을 계산한 뒤 스택 프레임에 복사합니다.
// 3. 현재 실행 주소를 복사해서 스택 프레임에 반환 주소로 넣습니다.
// 4. 실행 코드는 실행 주소를 함수 본문의 첫 번째 문장으로 갱신합니다.
// 5. 함수 본문에 있는 명령어들을 실행합니다.
// 6. 스택 프레임에 저장되어 있는 반환 주소를 명령어 주소에 복사합니다. 그리고 함수를 호출한 후의 문장으로 제어권을 넘깁니다
// 7. 호출 스택에서 스택 프레임을 삭제합니다.



// 함수 호출 비용 정리
// - 간단한 함수는 인라인으로 선언하세요
// - 함수를 처음 사용하기 전에 정의하세요
// - 사용하지 않는 다형성을 제거하세요
// - 사용하지 않는 인터페이스를 버리세요
// - 템플릿을 컴파일 타임에 구현을 선택하세요
// - PIMPL 관용구를 사용하는 코드를 제거하세요 -> PIMPL : 컴파일 방화벽으로 사용하는 코딩 관용구로 헤더 파일 하나를
//   수정했을 때 많은 소스 파일이 재 컴파일하지 않게 해주는 메커니즘입니다.
// - DLL을 호출하는 코드를 제거하세요
// - 멤버 함수 대신 정적 멤버 함수를 사용하세요
// - 가상 소멸자를 기본 클래스로 옮기세요



// 표현식 최적화
// - 표현식을 단순하게 만드세요
// - 상수를 함께 모으세요
// - 비용이 적은 연산자를 사용하세요
// - 부동 소수점 연산 대신 정수 연산을 사용하세요
// - double이 float보다 빠를 수 있습니다.
// - 반복 계산을 닫힌 형태로 바꾸세요


// 제어 흐름 최적화
// - if-elseif-else 대신 switch를 사용하세요
// - switch나 if 대신 가상함수를 사용하세요
// - 비용이 들지 않는 예외 처리를 사용하세요
// - 예외 사항을 사용하지 마세요


// 정리
// - 문장 수준에서 최적화할 때 문장의 비용을 크게 만드는 요인이 없다면 성능이 생각만큼 개선되지 않습니다.
// - 반복문에서 문장의 비용은 반복된 횟수만큼 커집니다.
// - 함수에서 문장의 비용은 함수가 호출된 횟수만큼 커집니다.
// - 자주 사용하는 관용구의 비용은 관용구가 사용된 횟수만큼 커집니다.
// - C++ 문장 중 일부에는 숨겨진 함수 호출이 포함되어 있습니다.
// - 운영체제를 호출하는 함수 코드는 비용이 많이 듭니다.
// - 함수 호출로 발생하는 오버헤드를 효과적으로 제거하는 방법은 함수를 인라인하는 것입니다.
// - 요즘은 PIMPL을 사용할 필요가 거의 없습니다. 현재 컴파일 하는 데 걸리는 시간은 PIMPL을 발명했을 때 걸렸던 시간의
//   1%에 불과합니다.
// - double 연산이 float 연산보다 빠를 수 있습니다.




int main()
{
    save("Optimized C++study.cpp");
}

// Chapter7 문장 최적화 完================================================
