


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.08.18 공부
// Chapter2 컴퓨터 하드웨어와 최적화
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"


// 이 장까지 코드가 없습니다.


// - C++ 프로그램은 '마치' 명령문을 순서대로 실행하는 것처럼 작동하기만 하면 됩니다.
// - C++11부터는 단일 실행 주소만 있다고 믿지 않습니다.
// - 특정 메모리 주소는 일반 메모리가 아닌 장치 레지스터가 될 수 있습니다.
// - C++11은 std::atomic<>이라는 마법 주문을 제공합니다. std::atomic<>은 메모리를 잠시 동안 마치
//   단순한 선형 바이트 저장소인 것처럼 작동하게 만들고, 멀티스레드 실행, 멀티 레이어 메모리 캐시등으로
//   현대 마이크로프로세서의 모든 복작성을 제거하려고 합니다.
//   일부 개발자는 volatile이 이러한 일을 한다고 생각하지만 잘못 알고 있는 겁니다.



// 정리
// - 메모리 접근 비용은 프로세서의 다른 비용을 압도합니다.
// - 정렬되지 않은 메모리에 접근하는 시간은 모든 바이트가 동일한 워드에 있을 때보다 2배 오래 걸립니다.
// - 많이 사용하는 메모리 위치는 적게 사용하는 메모리 위치보다 빨리 접근할 수 있습니다.
// - 인접한 위치에 있는 메모리는 인접하지 않은 위치에 있는 메모리보다 더 빨리 접근할 수 있습니다.
// - 캐싱 때문에 전체 프로그램의 콘텓스트에서 실행되는 함수는 테스트 하네스에서 실행되는 동일한 함수보다
//   느리게 실행될 수 있습니다.
// - 실행 스레드 간 공유하는 데이터에 접근하는 속도는 공유하지 않는 데이터에 접근하는 것보다 훨씬 느립니다.
// - 계산은 의사 결정보다 빠릅니다.
// - 모든 프로그램은 다른 프로그램들과 컴퓨터 자원을 놓고 경쟁합니다.
// - 프로그램이 시동 시간이나 최고 부하 시간에 실행되어야 한다면, 해당 프로그램의 성능은
//   해당 부하 상태에서 측정해야 합니다.
// - 모든 대입문, 함수 인수 초기화, 함수 반환문은 생성자를 호출하며, 그 생성자가 얼마나 많은 코드를 가지고 있는지는
//   알 수 없습니다.
// - 일부 문장은 많은 양의 계산을 숨깁니다. 문장의 형태로는 비용이 얼마나 드는지 알 수 없습니다.
// - 동기화 코드는 동시에 실행 가능한 스레드가 데이터를 공유할 때 얻을 수 있는 동시성을 줄입니다.

int main()
{
    save("Optimized C++study.cpp");
}

// Chapter2 컴퓨터 하드웨어와 최적화 完================================================
