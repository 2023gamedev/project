


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.1 소프트웨어 구조란?
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 이 책은 '어떻게 코딩할 것인가' 보다는 '어떻게 구조를 잡을 것인가'를 다룬다.
// 모든 프로그램, 심지어 'main() 함수에 전부 다 집어넣고 돌려보자' 식의 코드조차 어떤 식으로든 구조가 있다.

// 좋은 소프트웨어 구조란?
// 저자에게 좋은 구조란, 뭔가를 고쳐야 할 때 그럴 줄 알았다는 듯이 코드가 준비되어 있는 것을 의미한다.
// 즉, 코드를 거의 건드리지 않고도 적당한 함수 몇개만 호출하면 원하는 작업을 할 수 있어야 한다.

// 구조는 변경과 관련이 있다. 변화가 없는 코드는 출발선을 결코 떠나지 않는 달리기 선수와 다를바 없다.


// 코드를 고치는 방법
// 코드를 고쳐야 한다면 먼저 기존 코드를 이해해야 한다.
// 고치려는 코드와 관련된 부분은 머릿속에 집어넣어야 한다. (프로그래밍에서 가장 오래 걸리는 부분이다.)
// 머릿속에 코드에 대한 큰 그림을 그리고 나면 해결책을 금방 찾을 수 있다.


// 프로그래밍 흐름도는 다음과 같다.
//						
//
//			 ->			업무 할당		 ->
//			 |							   |
//		  코드 정리						코드 파악
//										   |
//			 ㄴ	    문제 해결 코드 작성	-
//
//
// 프로그래머의 업무를 간단히 요약한 그림



// 디커플링은 어떻게 도움이 되는가?
// 반드시 그런 건 아니지만, 소프트웨어 구조의 많은 부분이 '코드 파악'단계와 관련이 있다.
// 디커플링은 다양하게 정의할 수 있지만 저자는 양쪽 코드 중에서 한쪽이 없으면
// 코드를 이해 할 수 없을 때 둘이 커플링되어 있다고 본다.
// 두 코드를 디커플링하면, 각각을 따로 이해할 수 있게 된다.
// 작업에 들어가기 전에 알아야 할 지식의 양을 줄이는 것 - 소프트웨어 구조의 핵심목표이다.
// 디커플링에 다른 정의는 '어느 한 코드를 변경했을 때 다른 코드를 변경하지 않아도 된다'이다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.2 비용은?
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 사람들은 추상화,모듈화,디자인 패턴, 소프트웨어 구조에 열광한다.
// 구조화가 잘 이루어진 코드에서 일하는 건 즐거운 경험이다. 모두가 높은 생산성을 원한다.
// 좋은 구조는 생산성을 크게 높여준다.

// 하지만 어렵다. 미래를 예측해서 해야 하기 때문이다.
// 모두 고려한다고 여러 확장을 해 덕지덕지 붙으면 코드가 커지게 된다.
// 게임을 만들어야 하는데 게임엔진에만 신경쓰는 꼴이 되버리게 된다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.3 성능과 속도
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 성능은 가정에 기반한다.
// 어느 곳에서는 가상함수를 쓰지 않을 것이다 등등의 가정이 있어야만
// 그 구조나 코드를 제거해 성능을 높일 수 있다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.4 나쁜 코드의 장점
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// '제대로' 만드는 것을 선호하지만 엉성한 코드도 나름의 가치가 있다.
// 기획 확인에 필요한 기능만 간신히 돌아가도록 대강 코드를 작성하는 프로토타이핑 기법은
// 아주 적법한 프로그래밍 실천법이다.
// 기획 확인단계에서 자세하게 꼼꼼이 코드를 작성해봐야 그 기획이 무산되면 그 코드는 다 버리게 된다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.5 균형 잡기
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 우리에게 다음과 같은 목표가 있다.
// 1. 프로젝트 개발 기간 동안 코드를 쉽게 이해할 수 있도록 구조를 깔끔하게 만들고 싶다.
// 2. 실행 성능을 최적화하고 싶다.
// 3. 지금 개발 중인 기능을 최대한 빠르게 구현하고 싶다.
 
// 셋다 각각 장단점이 있기 때문에 트레이드오프 외에는 명쾌한 정답이 없다.
// 하지만 이런 어려움이 당신을 지겨워지지 않게 할 것이다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// Chapter 1 구조, 성능, 게임
// 1.6 단순함
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"

// 이런 제약을 완화할 방법이 있다면 단순함이다.
// 단순한기만 하면 되는것은 아니다.
// 우아한 해결책이란 일반적인, 그러니까 적은 로직으로도 많은 유스케이스를 정확하게 처리할 수 있는 코드를 작성하는 것이다.

// 몇가지 조언을 하자면
// - 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽소 빠르게 만들 수 있다. 하지만, 지금 고민 중인 코드에
//   유연함이 필요하다는 확신이 없다면 추상화와 디커플링을 적용하느라고 시간 낭비하지말자.
// - 개발 내내 성능을 고민하고, 최적화에 맞게 설계해야 한다. 하지만 가정을 코드에 박아 넣어야 하는 저수준의 핵심 최적화는
//   가능하면 늦게 하라.
// - 게임 기획 내용을 확인해볼수 있도록 빠르게 개발하되, 너무 서두르느라 코드를 엉망으로 만들지 말자.
//   결국 그 코드로 작업해야 하는 건 우리다.
// - 나중에 버릴 코드를 잘 만들겠다고 시간 낭비하지 말자. 록 스타들이 호텔 방을 어지르는 이유는 다음 날 계산하고 나가면
//   그만이라는 것을 알기 때문이다.
// - 무엇보다, 뭔가 재미있는 걸 만들고 싶다면 먼저 만드는 데에서 재미를 느껴보라


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}


// Chapter 1 구조, 성능, 게임  完================================================
