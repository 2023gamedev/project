// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    std::cout << "Hello World!\n";

    save("helloworld.cpp");
}




================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    std::cout << "Hello World!\n";

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    //IO 스트림

    std::cout << "There are " << 219 << " ways I love you." << std::endl;

    std::cout << std::format("There are {} ways I love you.", 219) << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    //IO 스트림

    std::cout << "There are " << 219 << " ways I love you." << std::endl;

    std::cout << std::format("There are {} ways I love you.", 219) << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    //IO 스트림

    std::cout << "There are " << 219 << " ways I love you." << std::endl;

    std::cout << std::format("There are {} ways I love you.", 219) << std::endl;


    // endl은 성능에 영향을 미치기 때문에 특히 루프와 같은 문장에서 남용하면 좋지 않다.

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"
/*
    컴파일러는 이 부분을 완전히 무시한다.
*/

int main()
{
    //IO 스트림

    int value;
    std::cin >> value;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 - 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념 - 이름이 속할 문맥을 정의한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"


namespace mycode {
    void foo() 
    {
        std::cout << "foo called in the mycode namespace" << std::endl;
    }
}


int main()
{
    mycode::foo();

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 - 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념 - 이름이 속할 문맥을 정의한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"


namespace mycode {
    void foo() 
    {
        std::cout << "foo called in the mycode namespace" << std::endl;
    }
}

using namespace mycode;

int main()
{
    foo();

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 - 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념 - 이름이 속할 문맥을 정의한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"


namespace mycode {
    void foo() 
    {
        std::cout << "foo called in the mycode namespace" << std::endl;
    }
}

using namespace mycode;

int main()
{
    foo(); // mycode::foo()와 같지만 남용하지말것

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 - 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념 - 이름이 속할 문맥을 정의한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

using namespace std;

int main()
{
    cout << "Hello, World!" << endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 - 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념 - 이름이 속할 문맥을 정의한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"


//특정한 항목만 가리키도록 하는 법
using std::cout;

int main()
{
    cout << "Hello, World!" << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 중첩 네임스페이스 - 다른 네임스페이스 안에 있는 네임스페이스를 말한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"


namespace MyLibraries::Networking::FTP {

}

//C++17 이전
namespace MyLibraries {
    namespace Networking {
        namespace FTP {

        }
    }
}

int main()
{


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 네임스페이스 앨리어스 - 네임스페이스의 이름을 다르게 만들거나 또는 더 짧게 만들 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

namespace MyLibraries::Networking::FTP {

}

namespace MyFTP = MyLibraries::Networking::FTP;


int main()
{


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 리터럴 - 코드에 표시한 숫자나 스트링과 같은 값을 의미한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

// 모두 숫자 123을 의미한다.
// 십진수 리터럴 : 123
// 8진수 리터럴  : 0173
// 16진수 리터럴 : 0x7B
// 이진수 리터럴 : 0b1111011 

// 또한 다음과 같은 리터럴도 지원한다.
// 부동소수점
// double 부동소수점 값
// 16진수 부동소수점 리터럴
// 단일 문자
// 0으로 끝나는 문자

// 숫자리터럴에서는 자릿수 구분자를 사용할 수 있다.
// 23'456'789

int main()
{


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 변수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

int main()
{
    int unititializedInt;
    int initializedInt{ 7 };
    std::cout << std::format("{} is a random value", unititializedInt) << std::endl;
    std::cout << std::format("{} was assigned an initial value", initializedInt) << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 변수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

int main()
{
    int unititializedInt;
    int initializedInt{ 7 }; // 균일 초기화(유니폼 초기화) 문법
    std::cout << std::format("{} is a random value", unititializedInt) << std::endl;
    std::cout << std::format("{} was assigned an initial value", initializedInt) << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 변수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

int main()
{
    int unititializedInt;
    int initializedInt{ 7 }; // 균일 초기화(유니폼 초기화) 문법
    std::cout << std::format("{} is a random value", unititializedInt) << std::endl;
    std::cout << std::format("{} was assigned an initial value", initializedInt) << std::endl;

    //C++은 강타입 언어이기에 항상 타입을 구체적으로 지정해야 한다.

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 변수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

#include "save.h"

int main()
{
    int unititializedInt;
    int initializedInt{ 7 }; // 균일 초기화(유니폼 초기화) 문법
    std::cout << std::format("{} is a random value", unititializedInt) << std::endl;
    std::cout << std::format("{} was assigned an initial value", initializedInt) << std::endl;

    //C++은 강타입 언어이기에 항상 타입을 구체적으로 지정해야 한다.

    // std::byte를 사용하면 메모리의 한 바이트를 다룬다는 사실을 분명하게 표현할 수 있다.

    std::byte b{ 42 };

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 숫자 경곗값 - C++은 현재 플랫폼에서 지원하는 숫자의 경곗값을 알아내는 표준 방법을 제공한다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    std::cout << "int:\n";
    std::cout << std::format("Max int value: {}\n", std::numeric_limits<int>::max());
    std::cout << std::format("Min int value: {}\n", std::numeric_limits<int>::min());
    std::cout << std::format("Lowest int value: {}\n", std::numeric_limits<int>::lowest());


    std::cout << "\ndouble:\n";
    std::cout << std::format("Max double value: {}\n", std::numeric_limits<double>::max());
    std::cout << std::format("Min double value: {}\n", std::numeric_limits<double>::min());
    std::cout << std::format("Lowest double value: {}\n", std::numeric_limits<double>::lowest());


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 0 초기화 
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    float myFLoat{}; // {}는 0초기자(zero initializer)라고 부른다.
    int myInt{};


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 캐스트 - 변수의 타입을 실행중에 바꿔준다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    
    float myFloat{ 3.14f };
    int i1{ (int)myFloat };                         // 첫번째 방법
    int i2{ int(myFloat) };                         // 두번째 방법
    int i3{ static_cast<int>(myFloat)};             // 세번째 방법




    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 캐스트 - 변수의 타입을 실행중에 바꿔준다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    
    float myFloat{ 3.14f };
    int i1{ (int)myFloat };                         // 첫번째 방법 - C++에서는 피해야 할 방식이지만 여전히 많이 사용
    int i2{ int(myFloat) };                         // 두번째 방법 - 거의 사용하지 않음
    int i3{ static_cast<int>(myFloat)};             // 세번째 방법 - 명확하고 권장하는 방식

    // 문맥에 따라 변수의 타입이 강제로 캐스트 될 때도 있다. - 강제형변한 char -> int


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 부동소수점수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// 부동소수점수중 특별한 값
// 1. +/- 무한 - 주어진 부동소수점수가 무한인지 검사하려면 std::isinf()를 사용한다.
// 2. NaN - 주어진 부동소수점수가 NaN인지 확인하려면 std::isnan()을 사용한다. - 둘다 <cmath>에 저장되어있다.

// 이처럼 특별한 부동소수점수를 구하려면 numeric_limits를 활용한다. 예를 들면 numeric_limits<double>::infinity

int main()
{
    

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    int someInteger{ 256 };
    short someShort;
    long someLong;
    float someFloat;
    double someDouble;

    someInteger++;
    someInteger *= 2;
    someShort = static_cast<short>(someInteger);
    someLong = someShort * 10000;
    someFloat = someLong + 0.785f;
    someDouble = static_cast<double>(someFloat) / 100000;
    std::cout << someDouble << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    int i{ 34 + 8 * 2 + 21 / 7 % 2 };


    // 연산의 실행 순서를 명확히 드러낼 수 있게 소괄호를 추가해주는 것이 좋다.
    int i2{ 34 + (8 * 2) + ((21 / 7) % 2) };

    std::cout << i << std::endl;
    std::cout << i2 << std::endl;


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

int main()
{
    int i{ 34 + 8 * 2 + 21 / 7 % 2 };


    // 연산의 실행 순서를 명확히 드러낼 수 있게 소괄호를 추가해주는 것이 좋다.
    int i2{ 34 + (8 * 2) + ((21 / 7) % 2) };

    std::cout << i << std::endl;
    std::cout << i2 << std::endl;

    //연산의 우선순위(위에서부터 아래로)
    // ++ --(사후 증가/감소)
    // ! ++ --(사전 증가/감소)
    // * / %
    // + -
    // << >>
    // &
    // ^
    // |
    // = += -= *= /= %= &= |= ^= <<= >>=
    // 이것 말고도 많이 있지만 나중에 소개한다.


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"


enum class PieceType { King, Queen, Rook, Pawn };

int main()
{
    PieceType piece{ PieceType::King };

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"


enum class PieceType 
{   King = 1, 
    Queen, 
    Rook = 10, 
    Pawn 
};

int main()
{
    PieceType piece{ PieceType::King };

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// enum 멤버는 정수로 표현되면 0, 1, 2, 3으로 표현되거나 밑처럼 범위를 별도 지정할 수 있따.
enum class PieceType 
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};

// 하지만  if(PieceType::Queen == 2) <- 이렇게 하면 오류가 뜬다. 
// 내부적으로 정수로 표현된다고 해서 자동으로 정수로 변환되지 않기에 위처럼 쓰려면 static_cast<int>를 해줘야 한다.


int main()
{
    PieceType piece{ PieceType::King };

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// enum 멤버는 정수로 표현되면 0, 1, 2, 3으로 표현되거나 밑처럼 범위를 별도 지정할 수 있따.
enum class PieceType : unsigned long // <- 이렇게 내부 표현타입을 바꿀수도 있다.
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};

// 하지만  if(PieceType::Queen == 2) <- 이렇게 하면 오류가 뜬다. 
// 내부적으로 정수로 표현된다고 해서 자동으로 정수로 변환되지 않기에 위처럼 쓰려면 static_cast<int>를 해줘야 한다.


int main()
{
    PieceType piece{ PieceType::King };

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// enum 멤버는 정수로 표현되면 0, 1, 2, 3으로 표현되거나 밑처럼 범위를 별도 지정할 수 있따.
enum class PieceType
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};

// 하지만  if(PieceType::Queen == 2) <- 이렇게 하면 오류가 뜬다. 
// 내부적으로 정수로 표현된다고 해서 자동으로 정수로 변환되지 않기에 위처럼 쓰려면 static_cast<int>를 해줘야 한다.


int main()
{
    PieceType piece{ PieceType::King };

    std::cout << static_cast<int>(piece) << std::endl;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

enum class PieceType
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};


// 서로 다른 열거 타입에 동일한 이름의 멤버가 존재할 수 있다.
enum class State{Unknown, Started, Finished};
enum class Error{None, BadInput, DiskFull, Unknown};




int main()
{
    PieceType piece{ PieceType::King };


    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

enum class PieceType
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};


// 서로 다른 열거 타입에 동일한 이름의 멤버가 존재할 수 있다.
enum class State{Unknown, Started, Finished};
enum class Error{None, BadInput, DiskFull, Unknown};




int main()
{

    // C++20부터 using enum을 선언하면 열것값을 길게 풀어 쓰지 않아도 된다.
    using enum PieceType;
    PieceType piece{ King };

   

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

enum class PieceType
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};


// 서로 다른 열거 타입에 동일한 이름의 멤버가 존재할 수 있다.
enum class State{Unknown, Started, Finished};
enum class Error{None, BadInput, DiskFull, Unknown};




int main()
{
    using PieceType::King;
    PieceType piece{ King };
    piece = PieceType::Queen;

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

enum class PieceType
{   King = 1,   //1
    Queen,      //2
    Rook = 10,  //10
    Pawn        //11
};


// 서로 다른 열거 타입에 동일한 이름의 멤버가 존재할 수 있다.
enum class State{Unknown, Started, Finished};
enum class Error{None, BadInput, DiskFull, Unknown};




int main()
{
    using PieceType::King;
    PieceType piece{ King };
    piece = PieceType::Queen;

    
    // 물론 using enum은 조심히 사용하여야 한다.

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// 예전 방식의 열거 타입
enum PieceType {PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn};


int main()
{
    // 상위 스코프에서 열거 타입 멤버의 이름을 그대로 사용할 수 잇다.
    PieceType piece{ PieceTypeKing };


    // 이렇게 쓰게 되면 컴파일 오류 발생
    //bool ok{ false };
    //enum Status {error, ok};
   

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 열거 타입 - enum
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <limits>

#include "save.h"

// 예전 방식의 열거 타입
enum PieceType {PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn};


int main()
{
    // 상위 스코프에서 열거 타입 멤버의 이름을 그대로 사용할 수 잇다.
    PieceType piece{ PieceTypeKing };


    // 이렇게 쓰게 되면 컴파일 오류 발생 - 타입에 안전하지 않다.
    //bool ok{ false };
    //enum Status {error, ok};
   

    save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 구조체
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;

#include "save.h"




int main()
{
	// 직원 레코드 생성 및 값 채우기
	Employee anEmployee;
	anEmployee.firstInitial = 'J';
	anEmployee.lastInitial = 'D';
	anEmployee.employeeNumber = 42;
	anEmployee.salary = 80000;
	// 직원 레코드에 저장된 값 출력하기
	std::cout << std::format("Employee: {} {}", anEmployee.firstInitial, anEmployee.lastInitial) << std::endl;
	std::cout << std::format("Number: {}", anEmployee.employeeNumber) << std::endl;
	std::cout << std::format("Salary: ${}", anEmployee.salary) << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 구조체 - 기존에 정의된 타입을 한 개 이상 묶어서 새로운 타입으로 정의할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;

#include "save.h"




int main()
{
	// 직원 레코드 생성 및 값 채우기
	Employee anEmployee;
	anEmployee.firstInitial = 'J';
	anEmployee.lastInitial = 'D';
	anEmployee.employeeNumber = 42;
	anEmployee.salary = 80000;
	// 직원 레코드에 저장된 값 출력하기
	std::cout << std::format("Employee: {} {}", anEmployee.firstInitial, anEmployee.lastInitial) << std::endl;
	std::cout << std::format("Number: {}", anEmployee.employeeNumber) << std::endl;
	std::cout << std::format("Salary: ${}", anEmployee.salary) << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;

#include "save.h"


// if/else문


int main()
{
	int i = 0;
	
	if (i > 4) {
		// 뭔가 작업한다.
	}
	else if (i > 2) {
		// 다른 일을 한다.
	}
	else {
		// 다른 일을 한다.
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;

#include "save.h"





int main()
{
	// if/else문

	int i = 0;
	
	if (i > 4) {
		// 뭔가 작업한다.
	}
	else if (i > 2) {
		// 다른 일을 한다.
	}
	else {
		// 다른 일을 한다.
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	// if/else문

	int i = 0;
	
	if (i > 4) {
		// 뭔가 작업한다.
	}
	else if (i > 2) {
		// 다른 일을 한다.
	}
	else {
		// 다른 일을 한다.
	}

	// if문안에 초기자를 넣을 수 있다.
	/*if (<초기자>; <조건문>) {

	}
	else if(<조건문>){

	}
	else{

	}
	*/
	// 초기자는 if의 본문, else if의 본문, else의 본문안에서만 사용할 수 있고 if문 밖에서는 사용이 불가능하다.
	// 활용한 예제는 추후에 설명


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	//switch 문

	int menuItem = 1;
	const int OpenMenuItem = 0;
	const int SaveMenuItem = 1;


	switch (menuItem)
	{
	case OpenMenuItem:
		//파일을 여는 코드
		break;

	case SaveMenuItem:
		// 파일을 저장하는 코드
		break;
	default:
		// 에러 메시지를 출력하는 코드
		break;
	}



	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	//switch 문

	enum class Mode{Default, Custom, Standard};

	int value{ 42 };
	Mode mode{};

	switch (mode)
	{
		using enum Mode;
	case Custom:
		value = 84;
	case Standard:
	case Default:
		// 작업을 수행한다.
		break;
	}



	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	//switch 문

	enum class Mode{Default, Custom, Standard};

	int value{ 42 };
	Mode mode{};

	switch (mode)  
	{
		using enum Mode;
	case Custom:
		value = 84;  // break이 없어 밑에 case가 실행되는 것을 fallthrough(흘려보내기)라 부른다.
	case Standard:
	case Default:
		// 작업을 수행한다.
		break;
	}



	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	//switch 문

	enum class Mode{Default, Custom, Standard};

	int value{ 42 };
	Mode mode{};

	switch (mode)  
	{
		using enum Mode;
	case Custom:
		value = 84;  // break이 없어 밑에 case가 실행되는 것을 fallthrough(흘려보내기)라 부른다.
		//[[fallthrough]] // fallthrough는 오류가 많아 경고메시지를 주는데 어트리뷰트를 지정하면 경고메시지를 주지 않는다.
	case Standard:
	case Default:
		// 작업을 수행한다.
		break;
	}



	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건문 - 어떤 값이 참 또는 거짓인지에 따라 주어진 코드를 실행할 수 있다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{
	//switch 문

	enum class Mode{Default, Custom, Standard};

	int value{ 42 };
	Mode mode{};

	switch (mode)  
	{
		using enum Mode;
	case Custom:
		value = 84;  // break이 없어 밑에 case가 실행되는 것을 fallthrough(흘려보내기)라 부른다.
		//[[fallthrough]] // fallthrough는 오류가 많아 경고메시지를 주는데 어트리뷰트를 지정하면 경고메시지를 주지 않는다.
	case Standard:
	case Default:
		// 작업을 수행한다.
		break;
	}
	// switch(<초기자>; <표현식> { <본문> } if문과 같이 초기자를 지정할 수 있다. 



	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 조건연산자 - 삼항연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"





int main()
{

	int i = 2;
	std::cout << ((i > 2) ? "yes" : "no");
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 논리연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"


// <, >, ==, !=, ! , <=>, &&, || 등이 있다.
// 논리 표현식을 평가할 떄 short-circuit logic을 사용한다.
// 다시 말해 표현식을 평가하는 도중에 최종 결과가 나오면 나머지 부분은 평가하지 않는다.
// ex)  if( a > 2 && 5 > a) <- a= 1이면 a는 a > 2에서 false이기에 이 5 > a 로 가지도 않고 if조건을 벗어난다. 


int main()
{

	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 논리연산자
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"


// <, >, ==, !=, ! , <=>, &&, || 등이 있다.
// 논리 표현식을 평가할 떄 short-circuit logic을 사용한다.
// 다시 말해 표현식을 평가하는 도중에 최종 결과가 나오면 나머지 부분은 평가하지 않는다.
// ex)  if( a > 2 && 5 > a) <- a= 1이면 a는 a > 2에서 false이기에 이 5 > a 로 가지도 않고 if조건을 벗어난다. 

// 그렇기에 논리식을 작성할 때에는 가볍게 검사할 수 있는 부분을 앞에 적고, 시간이 걸리는 부분은 뒤에 적는다.

int main()
{

	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 3방향 비교 연산자 - <=>(우주선 연산자)
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"


// 피연산자가 정수 타입일시 결과는 강한 순서(strong ordering)이라 부르며 다음 세가지중 하나가 된다.
// strong_ordering::less 첫 번째 피연산자가 두 번째 피연산자보다 작다.
// strong_ordering::greater 첫 번째 피연산자가 두 번째 피연산자보다 크다.
// strong_ordering::equal 두 연산자가 같다.

// 피연산자가 부동소수점 타입이라면 결과는 부분 순서(partial ordering)이라 부르며 다음 세가지중 하나가 된다.
// partial_ordering::less 첫 번째 피연산자가 두 번째 피연산자보다 작다.
// partial_ordering::greater 첫 번째 피연산자가 두 번째 피연산자보다 크다.
// partial_ordering::equivalent 두 연산자가 같다.
// partial_ordering::unordered 두 피연산자 중 하나는 숫자가 아니다.


int main()
{
	int i{ 11 };
	std::strong_ordering result{ i <=> 0 };
	if (result == std::strong_ordering::less) { std::cout << "less" << std::endl; }
	if (result == std::strong_ordering::greater) { std::cout << "greater" << std::endl; }
	if (result == std::strong_ordering::equal) { std::cout << "equal" << std::endl; }
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 3방향 비교 연산자 - <=>(우주선 연산자)
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// 피연산자가 정수 타입일시 결과는 강한 순서(strong ordering)이라 부르며 다음 세가지중 하나가 된다.
// strong_ordering::less 첫 번째 피연산자가 두 번째 피연산자보다 작다.
// strong_ordering::greater 첫 번째 피연산자가 두 번째 피연산자보다 크다.
// strong_ordering::equal 두 피연산자가 같다.

// 피연산자가 부동소수점 타입이라면 결과는 부분 순서(partial ordering)이라 부르며 다음 세가지중 하나가 된다.
// partial_ordering::less 첫 번째 피연산자가 두 번째 피연산자보다 작다.
// partial_ordering::greater 첫 번째 피연산자가 두 번째 피연산자보다 크다.
// partial_ordering::equivalent 두 피연산자가 같다.
// partial_ordering::unordered 두 피연산자 중 하나는 숫자가 아니다.

// 자신이 직접 정의한 타입에 대해 3방향 비교 연산을 구현할때 사용하는 약한 순서(weak ordering)도 있다.
// weak_ordering::less 첫 번째 피연산자가 두 번째 피연산자보다 작다.
// weak_ordering::greater 첫 번째 피연산자가 두 번째 피연산자보다 크다.
// weak_ordering::equivalent 두 피연산자가 같다.


// <compare>에서는 순서의 결과를 해석해주는 이름있는 비교함수인(named comparison function)인
// std:::is_eq(), is_neq(), is_lt(), is_lteq(), is_gt(), is_gteq()를 제공한다.
// 각각 == , != , <, <=, > , >= 비교한 결과를 true나 false로 리턴한다.

int main()
{
	int i{ 11 };
	std::strong_ordering result{ i <=> 0 };
	if (std::is_lt(result)) { std::cout << "less" << std::endl; }
	if (std::is_gt(result)) { std::cout << "greater" << std::endl; }
	if (std::is_eq(result)) { std::cout << "equal" << std::endl; }
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

void myFunction(int i, char c);


int main()
{

	
	save("helloworld.cpp");
}

void myFunction(int i, char c) {
	std::cout << std::format("ther value of i is {}", i) << std::endl;
	std::cout << std::format("ther value of c is {}", c) << std::endl;
}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

void myFunction(int i, char c);


int main()
{
	int someInt{ 1 };
	char someChar{ 't' };
	myFunction(8, 'a');
	myFunction(someInt, 'b');
	myFunction(5, someChar);
	
	save("helloworld.cpp");
}

void myFunction(int i, char c) {
	std::cout << std::format("ther value of i is {}", i) << std::endl;
	std::cout << std::format("ther value of c is {}", c) << std::endl;
}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

int addNumbers(int number1, int number2) {
	return number1 + number2;
}

int main()
{
	int sum{ addNumbers(5,3) };
	
	std::cout << sum << std::endl;
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


//함수 리턴 타입 추론 - auto - 컴파일러가 리턴타입을 알아서 지정할 수 있다. 
auto addNumbers(int number1, int number2) {
	return number1 + number2;
}

int main()
{
	int sum{ addNumbers(5,3) };
	
	std::cout << sum << std::endl;
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// 현재 함수 이름 - 모든함수는 내부적으로 __func__라는 로컬 변수가 정의되어있다. 이 변수의 값은 현재 함수의 이름이며,
// 주로 로그를 남기는데 활용한다.
int addNumbers(int number1, int number2) {
	std::cout << "Entering function " << __func__ << std::endl;
	return number1 + number2;
}

int main()
{
	int sum{ addNumbers(5,3) };
	
	std::cout << sum << std::endl;
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 함수
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// 함수 오버로딩 - 이름은 같지만 매개변수 구성은 다른 함수를 여러 개 제공한다는 뜻이다.
int addNumbers(int a, int b) {
	return a + b;
}
double addNumbers(double a, double b) {
	return a + b;
}

int main()
{
	std::cout << addNumbers(1, 2) << std::endl;			// int 버전을 호출한다.
	std::cout << addNumbers(1.11, 2.22) << std::endl;   // double 버전을 호출한다.
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

[[nodiscard]] int func() {
	return 42;
}

int main()
{
	func();
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

int func() {
	return 42;
}

int main()
{
	func();
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

[[nodiscard]] int func() {
	return 42;
}

int main()
{
	func();
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

[[nodiscard("Some explanation")]] int func() {
	return 42;
}

int main()
{
	func();
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// 리턴값에 아무런 작업을 하지 않으면 경고메시지 출력 () 에는 이유를 설명하는 스트링을 경고메시지에 추가 할수 있다.
[[nodiscard("Some explanation")]] int func() {
	return 42;
}

int main()
{
	func();
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[maybe_unused]] - 뭔가 사용하지 않았을 때 컴파일러가 경고 메시지를 출력하지 않도록 설정하는데 사용된다.

int func(int param1, int param2) {
	return 42;
}


int main()
{
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[maybe_unused]] - 뭔가 사용하지 않았을 때 컴파일러가 경고 메시지를 출력하지 않도록 설정하는데 사용된다.
int func(int param1, [[maybe_unused]] int param2) {
	return 42;
}



int main()
{
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[deprecated]] - 지원 중단된 대상임을 지정하는데 사용된다. 즉 현재 사용할 수는 있지만
// 권장하지 않는 대상을 표시한다.


//[[deprecated("Unsafe method, please use xyz")]] void func() {
//
//}



int main()
{
	//func();

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[likely]] 와 [[unlikely]] - 컴파일러가 최적화 작업을 수행하는데 도움을 줄 수 있다.
// 컴파일러와 하드웨어의 능력이 좋아져 필요한 경우가 드물다.



int main()
{
	int value{};
	if (value > 11) [[unlikely]] {
		// 필요한 작업을 수행한다.
	}
	else {
		// 필요한 작업을 수행 ㅎ나다.
	}

	switch (value)
	{
		[[likely]] case 1:
			// 필요한 작업을 수행한다.
			break;
		case 2:
			// 필요한 작업을 수행한다.
			break;
		[[unlikely]] case 12:
			// 필요한 작업을 수행한다.
			break;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[likely]] 와 [[unlikely]] - 컴파일러가 최적화 작업을 수행하는데 도움을 줄 수 있다.
// 예를 들어 if와 switch문에서 수행될 가능성이 높은 브래니를 표시할 수 있다.
// 컴파일러와 하드웨어의 능력이 좋아져 필요한 경우가 드물다.



int main()
{
	int value{};
	if (value > 11) [[unlikely]] {
		// 필요한 작업을 수행한다.
	}
	else {
		// 필요한 작업을 수행 ㅎ나다.
	}

	switch (value)
	{
		[[likely]] case 1:
			// 필요한 작업을 수행한다.
			break;
		case 2:
			// 필요한 작업을 수행한다.
			break;
		[[unlikely]] case 12:
			// 필요한 작업을 수행한다.
			break;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// 어트리뷰트 - 소스 코드에 벤더에서 제공하는 정보나 옵션을 추가하는 메커니즘이다.
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"

// [[likely]] 와 [[unlikely]] - 컴파일러가 최적화 작업을 수행하는데 도움을 줄 수 있다.
// 예를 들어 if와 switch문에서 수행될 가능성이 높은 브랜치를 표시할 수 있다.
// 컴파일러와 하드웨어의 능력이 좋아져 필요한 경우가 드물다.



int main()
{
	int value{};
	if (value > 11) [[unlikely]] {
		// 필요한 작업을 수행한다.
	}
	else {
		// 필요한 작업을 수행 한다.
	}

	switch (value)
	{
		[[likely]] case 1:
			// 필요한 작업을 수행한다.
			break;
		case 2:
			// 필요한 작업을 수행한다.
			break;
		[[unlikely]] case 12:
			// 필요한 작업을 수행한다.
			break;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	int myArray[3];
	myArray[0] = 0;
	myArray[1] = 0;
	myArray[2] = 0;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	// 한번에 0으로 초기화
	int myArray[3] = { 0 };
	int myArray2[3] = {};
	int myArray3[3]{};


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	// 한번에 0으로 초기화
	int myArray[3] = { 0 };
	int myArray2[3] = {};
	int myArray3[3]{};

	// 초기화 리스트
	int myArray4[]{ 1,2,3,4 }; // 컴파일러는 원소 네 개로 구성된 배열을 생성한다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	// 한번에 0으로 초기화
	int myArray[3] = { 0 };
	int myArray2[3] = {};
	int myArray3[3]{};

	// 초기화 리스트
	int myArray4[]{ 1,2,3,4 }; // 컴파일러는 원소 네 개로 구성된 배열을 생성한다.

	// 초기화 리스트에 나온 원소의 개수가 배열의 크기로 지정한 수보다 적으면 나머지 원소는 0으로 초기화된다.
	int myArray5[3]{ 2 }; // 첫번째 원소의 값만 2로 지정, 나머지 원소는 0으로 초기화

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	// 한번에 0으로 초기화
	int myArray[3] = { 0 };
	int myArray2[3] = {};
	int myArray3[3]{};

	// 초기화 리스트
	int myArray4[]{ 1,2,3,4 }; // 컴파일러는 원소 네 개로 구성된 배열을 생성한다.

	// 초기화 리스트에 나온 원소의 개수가 배열의 크기로 지정한 수보다 적으면 나머지 원소는 0으로 초기화된다.
	int myArray5[3]{ 2 }; // 첫번째 원소의 값만 2로 지정, 나머지 원소는 0으로 초기화

	// 스택기반의 C 스타일 배열의 크기는 std::size()함수로 구할 수 있다.(<array>헤더를 인클루드해야한다.)

	size_t arraySize{ std::size(myArray) };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.29 공부
// C 스타일 배열
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <compare>

//import employee;

#include "save.h"


// C++에서 배열을 선언할 때에는 반드시 배열의 크기를 지정해야 하는데 변수로 지정할 수는 없고
// 반드시 상수 또는 상수 표현식으로 지정해야 한다.

int main()
{
	// 한번에 0으로 초기화
	int myArray[3] = { 0 };
	int myArray2[3] = {};
	int myArray3[3]{};

	// 초기화 리스트
	int myArray4[]{ 1,2,3,4 }; // 컴파일러는 원소 네 개로 구성된 배열을 생성한다.

	// 초기화 리스트에 나온 원소의 개수가 배열의 크기로 지정한 수보다 적으면 나머지 원소는 0으로 초기화된다.
	int myArray5[3]{ 2 }; // 첫번째 원소의 값만 2로 지정, 나머지 원소는 0으로 초기화

	// 스택기반의 C 스타일 배열의 크기는 std::size()함수로 구할 수 있다.(<array>헤더를 인클루드해야한다.)

	size_t arraySize{ std::size(myArray) };

	// 이차원 배열은 바둑판에 비유할 수 있다.
	char ticTacToeBoard[3][3];
	ticTacToeBoard[1][1] = 'o';

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.15 std::array
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>

//import employee;

#include "save.h"


// C++에서는 std::array라는 고정 크기 컨테이너를 제공한다.
// 배열에 비해 장점이 많다.
// 1. 항상 크기를 정확히 알 수 있다. 
// 2. 자동으로 포인터를 캐스트하지 않아서 특정한 종류의 버그를 방지할 수 있다.
// 3. 반복자로 배열에 대한 반복문을 쉽게 작성할 수 있다.

int main()
{
	std::array<int, 3> arr{ 9,8,7 };
	std::cout << std::format("Array size = {}", arr.size()) << std::endl;
	std::cout << std::format("2nd element = {}", arr[1]) << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.15 std::array
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>

//import employee;

#include "save.h"


// C++에서는 std::array라는 고정 크기 컨테이너를 제공한다.
// 배열에 비해 장점이 많다.
// 1. 항상 크기를 정확히 알 수 있다. 
// 2. 자동으로 포인터를 캐스트하지 않아서 특정한 종류의 버그를 방지할 수 있다.
// 3. 반복자로 배열에 대한 반복문을 쉽게 작성할 수 있다.

int main()
{
	std::array<int, 3> arr{ 9,8,7 };
	std::cout << std::format("Array size = {}", arr.size()) << std::endl;
	std::cout << std::format("2nd element = {}", arr[1]) << std::endl;


	// C++는 CTAD(클래스 템플릿 인수 추론)이라는 기능을 제공한다. 자세한 내용은 나중에 설명하겠다.
	// 꺾쇠괄호 사이에 템플릿 타입을 지정하지 않아도 된다는 정도만 알고 넘어가자.
	std::array arr2{ 9,8,7 };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.16 std::vector
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;

#include "save.h"


// C++에서는 크기가 고정되지 않은 컨테이너를 다양하게 제공한다. 대표적으로 std::vector가 있다.


int main()
{	
	// 정수 타입 벡터를 생성한다.
	std::vector<int> myVector{ 11,22 };

	// push_back()을 이용하여 생성한 벡터에 정숫값을 몇 개 더 추가한다.
	myVector.push_back(33);
	myVector.push_back(44);

	// 원소에 접근한다.
	std::cout << std::format("1st element : {}", myVector[0]) << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.16 std::vector
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;

#include "save.h"


// C++에서는 크기가 고정되지 않은 컨테이너를 다양하게 제공한다. 대표적으로 std::vector가 있다.


int main()
{	
	// 정수 타입 벡터를 생성한다.
	std::vector<int> myVector{ 11,22 };

	// push_back()을 이용하여 생성한 벡터에 정숫값을 몇 개 더 추가한다.
	myVector.push_back(33);
	myVector.push_back(44);

	// 원소에 접근한다.
	std::cout << std::format("1st element : {}", myVector[0]) << std::endl;

	// vector는 제네릭 컨테이너다. 거의 모든 종류의 객체를 담을 수 있다.
	// 그러므로 반드시 꺾쇠괄호 안에 원하는 객체 타입을 명시해야 한다.


	// std::vector도 CTAD를 지원한다.
	std::vector myVector2{ 11,22 };


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.17 std::pair
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;

#include "save.h"

// std::pair 클래스 템플릿은 두 값을 하나로 묶는다.
// 각 값은 public 데이터 멤버인 first와 second로 접근할 수 있다.


int main()
{	
	std::pair<double, int> myPair{ 1.23,5 };
	std::cout << std::format("{} {}", myPair.first, myPair.second);

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.17 std::pair
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;

#include "save.h"

// std::pair 클래스 템플릿은 두 값을 하나로 묶는다.
// 각 값은 public 데이터 멤버인 first와 second로 접근할 수 있다.


int main()
{	
	std::pair<double, int> myPair{ 1.23,5 };
	std::cout << std::format("{} {}", myPair.first, myPair.second);

	// pair도 CTAD를 지원한다.
	std::pair myPair2{ 1.23, 5 };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.18 std::optional
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <optional>

//import employee;

#include "save.h"


// std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다.
// optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다.
// 또한 값을 리턴할 수도 있고, 그렇지 않응 수도 있는 함수의 리턴 타입으로 사용 되기도 한다.

std::optional<int> getData(bool giveIt) {
	if (giveIt) {
		return 42;
	}
	return std::nullopt; // 또는 그냥 {};
}


int main()
{	
	std::optional<int> data1{ getData(true) };
	std::optional<int> data2{ getData(false) };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.18 std::optional
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <optional>

//import employee;

#include "save.h"


// std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다.
// optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다.
// 또한 값을 리턴할 수도 있고, 그렇지 않응 수도 있는 함수의 리턴 타입으로 사용 되기도 한다.

std::optional<int> getData(bool giveIt) {
	if (giveIt) {
		return 42;
	}
	return std::nullopt; // 또는 그냥 {};
}


int main()
{	
	std::optional<int> data1{ getData(true) };
	std::optional<int> data2{ getData(false) };


	std::cout << "data1.has_value = " << data1.has_value() << std::endl;
	if (data2) {
		std::cout << "data2 has a value. " << std::endl;
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.18 std::optional
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <optional>

//import employee;

#include "save.h"


// std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다.
// optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다.
// 또한 값을 리턴할 수도 있고, 그렇지 않응 수도 있는 함수의 리턴 타입으로 사용 되기도 한다.

std::optional<int> getData(bool giveIt) {
	if (giveIt) {
		return 42;
	}
	return std::nullopt; // 또는 그냥 {};
}


int main()
{	
	std::optional<int> data1{ getData(true) };
	std::optional<int> data2{ getData(false) };


	std::cout << "data1.has_value = " << data1.has_value() << std::endl;
	if (data2) {
		std::cout << "data2 has a value. " << std::endl;
	}

	std::cout << "data.value = " << data1.value() << std::endl;
	std::cout << "data.value = " << *data1 << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.18 std::optional
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <optional>

//import employee;

#include "save.h"


// std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다.
// optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다.
// 또한 값을 리턴할 수도 있고, 그렇지 않응 수도 있는 함수의 리턴 타입으로 사용 되기도 한다.

std::optional<int> getData(bool giveIt) {
	if (giveIt) {
		return 42;
	}
	return std::nullopt; // 또는 그냥 {};
}


int main()
{	
	std::optional<int> data1{ getData(true) };
	std::optional<int> data2{ getData(false) };


	std::cout << "data1.has_value = " << data1.has_value() << std::endl;
	if (data2) {
		std::cout << "data2 has a value. " << std::endl;
	}

	std::cout << "data.value = " << data1.value() << std::endl;
	std::cout << "data.value = " << *data1 << std::endl;

	// value_or를 사용하면 optional에 값이 있을 때는 그 값을 리턴하고 없을 때는 다른 값을 리턴한다.
	std::cout << "data2.value = " << data2.value_or(0) << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.18 std::optional
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <optional>

//import employee;

#include "save.h"


// std::optional은 특정한 타입의 값을 가질 수도 있고, 아무 값도 가지지 않을 수도 있다.
// optional은 기본적으로 함수 매개변수에 전달된 값이 없을 수도 있는 상황에 사용된다.
// 또한 값을 리턴할 수도 있고, 그렇지 않응 수도 있는 함수의 리턴 타입으로 사용 되기도 한다.

std::optional<int> getData(bool giveIt) {
	if (giveIt) {
		return 42;
	}
	return std::nullopt; // 또는 그냥 {};
}


int main()
{	
	std::optional<int> data1{ getData(true) };
	std::optional<int> data2{ getData(false) };


	std::cout << "data1.has_value = " << data1.has_value() << std::endl;
	if (data2) {
		std::cout << "data2 has a value. " << std::endl;
	}

	std::cout << "data.value = " << data1.value() << std::endl;
	std::cout << "data.value = " << *data1 << std::endl;

	// value_or를 사용하면 optional에 값이 있을 때는 그 값을 리턴하고 없을 때는 다른 값을 리턴한다.
	std::cout << "data2.value = " << data2.value_or(0) << std::endl;
	//이때 레퍼런스는 optional에 담을 수 없다. 따라서 optional<T&>와 같이 작성할 수 없다.
	// 대신 optional에 포인터를 저장할 수는 있다.

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.19 구조적 바인딩
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>

//import employee;

#include "save.h"


// 구조적 바인딩을 이용하면 여러 변수를 선언할 때 array,struct, pair 등에 담긴 원소들을
// 이용하여 변숫값을 한꺼번에 초기화할 수 있다.


int main()
{	
	std::array values{ 11,22,33 };

	//이 상태에서 x,y,z 변수를 선언할 때 초깃값을 values 배열에 담아서 초기화할 수 있다.
	auto [x, y, z] {values};  
	// 구조적바인딩에서 왼쪽에 나온 선언할 변수 개수와 오른쪽에 나온 표현식에 담긴 값의 개수는 반드시 일치해야 한다.



	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.19 구조적 바인딩
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>

//import employee;

#include "save.h"


// 구조적 바인딩을 이용하면 여러 변수를 선언할 때 array,struct, pair 등에 담긴 원소들을
// 이용하여 변숫값을 한꺼번에 초기화할 수 있다.


int main()
{	
	struct Point { double m_x, m_y, m_z; };
	Point point;
	point.m_x = 1.0; point.m_y = 2.0; point.m_z = 3.0;
	auto [x, y, z] {point};


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.19 구조적 바인딩
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// 구조적 바인딩을 이용하면 여러 변수를 선언할 때 array,struct, pair 등에 담긴 원소들을
// 이용하여 변숫값을 한꺼번에 초기화할 수 있다.


int main()
{	
	std::array values{ 11,22,33 };

	// 이 상태에서 x,y,z 변수를 선언할 때 초깃값을 values 배열에 담아서 초기화할 수 있다.
	auto [x, y, z] {values};  
	// 구조적바인딩에서 왼쪽에 나온 선언할 변수 개수와 오른쪽에 나온 표현식에 담긴 값의 개수는 반드시 일치해야 한다.

	// struct
	struct Point { double m_x, m_y, m_z; };
	Point point;
	point.m_x = 1.0; point.m_y = 2.0; point.m_z = 3.0;
	auto [x2, y2, z2] {point};

	// pair
	std::pair myPair{ "hello", 5 };
	auto [theString, theInt] {myPair}; // 구조적 바인딩을 이용해 나누기
	std::cout << std::format("theString: {}", theString) << std::endl;
	std::cout << std::format("theInt: {}", theInt) << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 1. while문 


int main()
{	
	int i{ 0 };
	while (i < 5) {
		std::cout << "This is silly" << std::endl;
		++i;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 2. do while문 


int main()
{	
	int i{ 100 };
	do
	{
		std::cout << "This is silly." << std::endl;
		++i;
	} while (i < 5);


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 2. do while문 


int main()
{	
	int i{ 100 };
	do
	{
		//do부분을 최소 한번 실행
		std::cout << "This is silly." << std::endl;
		++i;
	} while (i < 5);


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 3. for문 


int main()
{	
	for (int i{ 0 }; i < 5; ++i) {
		std::cout << "This is silly." << std::endl;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 4. 범위 기반 for문 


int main()
{	
	// 범위 기반 for문으로 이 배열의 모든 원소에 대한 복제본을 화면에 출력한다.

	std::array arr{ 1,2,3,4 };
	for (int i : arr) {
		std::cout << i << std::endl;
	}


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.20 반복문
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <array>
#include <utility>

//import employee;

#include "save.h"


// C++는 while, do/while, for, 범위 기반 for 등 네가지 반복메커니즘을 제공한다.

// 4. 범위 기반 for문 


int main()
{	
	// 범위 기반 for문으로 이 배열의 모든 원소에 대한 복제본을 화면에 출력한다.

	std::array arr{ 1,2,3,4 };
	for (int i : arr) {
		std::cout << i << std::endl;
	}


	// C++20부터는 범위 기반 for문에서도 초기자를 사용할 수 있다.
	// 문법 - for(<초기자>; <for-범위-선언> " <for-범위-초기자>) { <본문> }
	for (std::array arr2{ 1,2,3,4 }; int i : arr2) { std::cout << i << std::endl; }
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.21 초기자 리스트
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <initializer_list>

//import employee;

#include "save.h"


// 초기자 리스트는 <initializer_list> 헤더 파일에 정의되어 있으며,
// 이를 활용하면 여러 인수를 받는 함수를 쉽게 작성할 수 있다.

int makeSum(std::initializer_list<int> values) {
	int total{ 0 };
	for (int value : values) {
		total += value;
	}
	return total;
}

int main()
{	
	int a{ makeSum({1,2,3}) };
	int b{ makeSum({10,20,30,40,50,60}) };


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.21 초기자 리스트
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <initializer_list>

//import employee;

#include "save.h"


// 초기자 리스트는 <initializer_list> 헤더 파일에 정의되어 있으며,
// 이를 활용하면 여러 인수를 받는 함수를 쉽게 작성할 수 있다.

int makeSum(std::initializer_list<int> values) {
	int total{ 0 };
	for (int value : values) {
		total += value;
	}
	return total;
}

int main()
{	
	int a{ makeSum({1,2,3}) };
	int b{ makeSum({10,20,30,40,50,60}) };

	std::cout << a << std::endl;
	std::cout << b << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.21 초기자 리스트
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <initializer_list>

//import employee;

#include "save.h"


// 초기자 리스트는 <initializer_list> 헤더 파일에 정의되어 있으며,
// 이를 활용하면 여러 인수를 받는 함수를 쉽게 작성할 수 있다.

int makeSum(std::initializer_list<int> values) {
	int total{ 0 };
	for (int value : values) {
		total += value;
	}
	return total;
}

int main()
{	
	int a{ makeSum({1,2,3}) };
	int b{ makeSum({10,20,30,40,50,60}) };

	std::cout << a << std::endl;
	std::cout << b << std::endl;

	// 초기자 리스트는 타입에 안전하다. 그러므로 초기자 리스트를 정의할 때 지정한 타입만 허용한다.
	// int c{ makeSum({1,2,3.0}) }; <- 3.0에 빨간줄

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.22 C++의 스트링
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <string>

//import employee;

#include "save.h"




int main()
{	
	std::string myString{ "Hello, World" };
	std::cout << std::format("The value of MyString is {} ", myString) << std::endl;
	std::cout << std::format("The second letter is {} ", myString[1]) << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.23 C++객체지향의 특성
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"

// C++은 C와 달리 객체지향적이다.(OOP)
// 1. 클래스 정의
// 클래스는 객체의 특성을 정의한 것이다. 


int main()
{	
	

	save("helloworld.cpp");
	save("airline_ticket.cppm");
	save("airline_ticket.cpp");
}

================================================



================================================
////////////////////////////////////////////////////////////////
// airline_ticket.cppm
////////////////////////////////////////////////////////////////

export module airline_ticket;

#include <string>


export class AirlineTicket {
public:
	AirlineTicket();
	~AirlineTicket();

	double calculatePriceInDollars();
	std::string getPassengerName();
	void setPassengerName(std::string name);

	int getNumberOfMiles();
	void setNumberOfMiles(int miles);

	bool hasEliteSuperRewardsStatus();
	void setHasEliteSuperRewardsStatus(bool status);

private:
	std::string m_passengerName;
	int m_numberOfMiles;
	bool m_hasEliteSuperRewardStatus;
};================================================



================================================
////////////////////////////////////////////////////////////////
// airline_ticket.cpp
////////////////////////////////////////////////////////////////

module airline_ticket;

AirlineTicket::AirlineTicket()
	: m_passengerName{ "Unknown Passenger" }
	, m_numberOfMiles{ 0 }
	, m_hasEliteSuperRewardStatus{ false }
{

}


// 생성자로 데이터 멤버를 초기화하는 다른 방법
//AirlineTicket::AirlineTicket() {
//	// 데이터 멤버 초기화
//	m_passengerName = "Unknown Passenger";
//	m_numberOfMiles = 0;
//	m_hasEliteSuperRewardStatus = false;
//}
// 아니면 생성자에서 다른일을 하지 않는다면 클래스 정의코드에서 곧바로 데이터 멤버를 초기화 할 수도 있다.

AirlineTicket::~AirlineTicket() {
	// 소멸에 관해서는 따로 할 일이 없다.
}

double AirlineTicket::calculatePriceInDollars()
{
	if (hasEliteSuperRewardsStatus()) {
		// 우수 등급 회원에게는 무료 티켓을 제공한다.
		return 0;
	}

	// 티켓 가격은 비행 거리에 0.1을 곱한 값이다.
	// 실제로 항공사에서 적용하는 공식은 이보다 복잡하다.
	return getNumberOfMiles() * 0.1;
}

std::string AirlineTicket::getPassengerName()
{
	return m_passengerName;
}

void AirlineTicket::setPassengerName(std::string name)
{
	m_passengerName = name;
}
int AirlineTicket::getNumberOfMiles()
{
	return m_numberOfMiles;
}
void AirlineTicket::setNumberOfMiles(int miles)
{
	m_numberOfMiles = miles;
}
bool AirlineTicket::hasEliteSuperRewardsStatus()
{
	return m_hasEliteSuperRewardStatus;
}
void AirlineTicket::setHasEliteSuperRewardsStatus(bool status)
{
	m_hasEliteSuperRewardStatus = status;
}




================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.23 C++객체지향의 특성
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;

#include "save.h"

// C++은 C와 달리 객체지향적이다.(OOP)
// 2.클래스 사용

import airline_ticket; // 사용하려면 먼저 모듈을 임포트해야 한다.

int main()
{	
	AirlineTicket myTicket;
	std::string strName{ "Sherman T. Socketwrench" };
	//myTicket.setPassengerName(strName);
	myTicket.setNumberOfMiles(700);
	double cost{ myTicket.calculatePriceInDollars() };
	std::cout << std::format("This ticket will cost ${}", cost) << std::endl;



	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.23 C++객체지향의 특성
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <string>

//import employee;

#include "save.h"

// C++은 C와 달리 객체지향적이다.(OOP)
// 2.클래스 사용

import airline_ticket; // 사용하려면 먼저 모듈을 임포트해야 한다.



int main()
{	
	AirlineTicket myTicket;
	myTicket.setPassengerName("Sherman T.Socketwrench");
	myTicket.setNumberOfMiles(700);
	double cost{ myTicket.calculatePriceInDollars() };
	std::cout << std::format("This ticket will cost ${}", cost) << std::endl;



	save("helloworld.cpp");
	save("airline_ticket.cppm");
	//save("airline_ticket.cpp");
}

================================================



================================================
////////////////////////////////////////////////////////////////
// airline_ticket.cppm
////////////////////////////////////////////////////////////////

export module airline_ticket;

import <string>;


export class AirlineTicket {
public:
	AirlineTicket();
	~AirlineTicket();

	double calculatePriceInDollars();
	std::string getPassengerName();
	void setPassengerName(const std::string name);

	int getNumberOfMiles();
	void setNumberOfMiles(int miles);

	bool hasEliteSuperRewardsStatus();
	void setHasEliteSuperRewardsStatus(bool status);

private:
	std::string m_passengerName;
	int m_numberOfMiles;
	bool m_hasEliteSuperRewardStatus;
};================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.24 스코프 지정
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"


// C++ 프로그래머라면 스코프의 개념을 잘 알아야 한다.
// 프로그램에 나오는 모든 이름은 저마다의 스코프가 있다.
// 가장 안쪽 스코프에 해당 이름이 없으면 그 바깥 스코프에서 검색하는 등 글로벌 스코프에 이를때까지 계속된다.
// 네임스페이스나 함수, 중괄호로 묶은 블록, 클래스 등에 없는 이름은 모두 글로벌 스코프에 있다고 간주한다.
// 그 이름이 글로벌 스코프에도 없다면 컴파일러는 알 수 없는 기호 에러를 발생시킨다.

// 스코프 지정 연산자(::)를 사용하여 원하는 스코프를 지정할 수 있다.

class Demo {
public:
	int get() { return 5; }
};

int get() { return 10; }

namespace NS {
	int get() { return 20; }
}


int main()
{	
	Demo d;
	std::cout << d.get() << std::endl;
	std::cout << NS::get() << std::endl;
	std::cout << ::get() << std::endl;
	std::cout << get() << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.24 스코프 지정
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"


// C++ 프로그래머라면 스코프의 개념을 잘 알아야 한다.
// 프로그램에 나오는 모든 이름은 저마다의 스코프가 있다.
// 가장 안쪽 스코프에 해당 이름이 없으면 그 바깥 스코프에서 검색하는 등 글로벌 스코프에 이를때까지 계속된다.
// 네임스페이스나 함수, 중괄호로 묶은 블록, 클래스 등에 없는 이름은 모두 글로벌 스코프에 있다고 간주한다.
// 그 이름이 글로벌 스코프에도 없다면 컴파일러는 알 수 없는 기호 에러를 발생시킨다.

// 스코프 지정 연산자(::)를 사용하여 원하는 스코프를 지정할 수 있다.

class Demo {
public:
	int get() { return 5; }
};

int get() { return 10; }

namespace NS {
	int get() { return 20; }
}


int main()
{	

	// using namespace NS; 를 쓰게 되면 모호해져서 에러가 발생한다.

	Demo d;
	std::cout << d.get() << std::endl;
	std::cout << NS::get() << std::endl;
	std::cout << ::get() << std::endl;
	std::cout << get() << std::endl;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	



	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	
	// C++11 이전에는 변수를 초기화하는 방법이 서로 달랐다.
	CircleSturct myCircle1 = { 10,10, 2.5 };
	CircleClass myCircle2(10, 10, 2.5);


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	
	// C++11 이전에는 변수를 초기화하는 방법이 서로 달랐다.
	CircleSturct myCircle1 = { 10,10, 2.5 };
	CircleClass myCircle2(10, 10, 2.5);

	// C++11
	CircleSturct myCircle3 = { 10,10, 2.5 };
	CircleClass myCircle4 = { 10, 10, 2.5 };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	
	// C++11 이전에는 변수를 초기화하는 방법이 서로 달랐다.
	CircleSturct myCircle1 = { 10,10, 2.5 };
	CircleClass myCircle2(10, 10, 2.5);

	// C++11
	CircleSturct myCircle3{ 10,10, 2.5 };
	CircleClass myCircle4{ 10, 10, 2.5 };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	
	Employee anEmplyee{ 'J', 'D', 42, 80'000 };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	
	int a = 3;
	int  b(3);
	int c = { 3 }; // 균일 초기화
	int d{ 3 };    // 균일 초기화

	// 영 초기화
	int e{};

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};

void func(int i) { }
int main()
{	
	int a = 3;
	int  b(3);
	int c = { 3 }; // 균일 초기화
	int d{ 3 };    // 균일 초기화

	// 영 초기화
	int e{};

	// 균일 초기화를 사용하면 축소변환(좁히기)을 방지할 수 있다.
	int x = 3.14;
	func(3.14);


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};

void func(int i) { }
int main()
{	
	int a = 3;
	int  b(3);
	int c = { 3 }; // 균일 초기화
	int d{ 3 };    // 균일 초기화

	// 영 초기화
	int e{};

	// 균일 초기화를 사용하면 축소변환(좁히기)을 방지할 수 있다.
	int x = 3.14; // 둘다 3으로 절사가 일어난다.
	func(3.14);


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};

void func(int i) { }
int main()
{	
	int a = 3;
	int  b(3);
	int c = { 3 }; // 균일 초기화
	int d{ 3 };    // 균일 초기화

	// 영 초기화
	int e{};

	// 균일 초기화를 사용하면 축소변환(좁히기)을 방지할 수 있다.
	//int x{ 3.14 };   // 에러 발생
	//func({ 3.14 });  // 에러 발생


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"

struct CircleSturct {
	int x, y;
	double radius;
};

class CircleClass {
public:
	CircleClass(int x, int y, double radious)
		: m_x {x}, m_y {y}, m_radious {radious}{}
private:
	int m_x, m_y;
	double m_radious;
};


int main()
{	

	// 균일 초기화는 동적으로 할당되는 배열을 초기화할 때도 적용가능하다.
	int* pArray = new int[4] {0, 1, 2, 3};

	//C++20부터는 배열의 크기를 생략할 수 있다.
	int* pArray2 = new int[] {0, 1, 2, 3};


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

import employee;
//import airline_ticket;

#include "save.h"


// 클래스에서 배열을 초기화할 때도 사용할 수 있다.
class MyClass {
public:
	MyClass()
		: m_array{0,1,2,3}{}
private:

	int m_array[4];
};


int main()
{	

	// 균일 초기화는 동적으로 할당되는 배열을 초기화할 때도 적용가능하다.
	int* pArray = new int[4] {0, 1, 2, 3};

	//C++20부터는 배열의 크기를 생략할 수 있다.
	int* pArray2 = new int[] {0, 1, 2, 3};


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"


// 1. 지정 초기자 (C++20) - 묶음 타입의 데이터 멤버를 초기화하는데 사용된다.
// 묶음타입이란 public 데이터 멤버만 갖는 배열 타입 객체나 구조체 객체, 클래스 객체를 말한다.

// 지정 초기자로 초기화되지 않은 데이터 멤버는 모두 디폴트값으로 초기화된다.
// - 클래스 내부 초기자를 가진 데이터 멤버는 거기서 지정된 값을 갖게 된다.
// - 클래스 내부 초기자가 없는 데이터 멤버는 0으로 초기화된다.

struct Employee {
	char firstInitial;
	char lastInitial;
	int employeeNumber;
	int salary{ 75'000 };
};

int main()
{	
	Employee anEmployee{
		.firstInitial = 'J',
		.lastInitial = 'D',
		.employeeNumber = 42,
		.salary = 80'000
	};
	// 이렇게 지정 초기자를 사용하면 균일 초기자를 사용할 때보다 초기화할 대상을 훨씬 쉽게 파악할 수 있다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"


// 1. 지정 초기자 (C++20) - 묶음 타입의 데이터 멤버를 초기화하는데 사용된다.
// 묶음타입이란 public 데이터 멤버만 갖는 배열 타입 객체나 구조체 객체, 클래스 객체를 말한다.

// 지정 초기자로 초기화되지 않은 데이터 멤버는 모두 디폴트값으로 초기화된다.
// - 클래스 내부 초기자를 가진 데이터 멤버는 거기서 지정된 값을 갖게 된다.
// - 클래스 내부 초기자가 없는 데이터 멤버는 0으로 초기화된다.

struct Employee {
	char firstInitial;
	char lastInitial;
	int employeeNumber;
	int salary{ 75'000 };
};

int main()
{	
	Employee anEmployee{
		.firstInitial = 'J',
		.lastInitial = 'D',
		.employeeNumber = 42,
		.salary = 80'000
	};
	// 이렇게 지정 초기자를 사용하면 균일 초기자를 사용할 때보다 초기화할 대상을 훨씬 쉽게 파악할 수 있다.

	Employee anEmployee2{
	.firstInitial = 'J',
	.lastInitial = 'D', // employeeNumber는 0으로 초기화된다.
	.salary = 80'000
	};

	Employee anEmployee3{
	.firstInitial = 'J',
	.lastInitial = 'D', // employeeNumber는 0으로 초기화된다. salary는 내부 초기자가 있으므로 75'000이 된다. 
	};

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.25 균일 초기화
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"


// 1. 지정 초기자 (C++20) - 묶음 타입의 데이터 멤버를 초기화하는데 사용된다.
// 묶음타입이란 public 데이터 멤버만 갖는 배열 타입 객체나 구조체 객체, 클래스 객체를 말한다.

// 지정 초기자로 초기화되지 않은 데이터 멤버는 모두 디폴트값으로 초기화된다.
// - 클래스 내부 초기자를 가진 데이터 멤버는 거기서 지정된 값을 갖게 된다.
// - 클래스 내부 초기자가 없는 데이터 멤버는 0으로 초기화된다.

struct Employee {
	char firstInitial;
	char lastInitial;
	int employeeNumber;
	int salary{ 75'000 };
};

int main()
{	
	Employee anEmployee{
		.firstInitial = 'J',
		.lastInitial = 'D',
		.employeeNumber = 42,
		.salary = 80'000
	};
	// 이렇게 지정 초기자를 사용하면 균일 초기자를 사용할 때보다 초기화할 대상을 훨씬 쉽게 파악할 수 있다.

	Employee anEmployee2{
	.firstInitial = 'J',
	.lastInitial = 'D', // employeeNumber는 0으로 초기화된다.
	.salary = 80'000
	};

	Employee anEmployee3{
	.firstInitial = 'J',
	.lastInitial = 'D', // employeeNumber는 0으로 초기화된다. salary는 내부 초기자가 있으므로 75'000이 된다. 
	};

	// 지정 초기자의 마지막 장점은 구조체의 멤버를 추가하더라도 지정 초기자를 이용한 기존 코드는 그대로 작동한다는 것이다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. 스택과 프리스토어
// C++ 애플리케이션에서 사용하는 메모리는 크게 스택과 프리스토어로 나뉜다.
// 스택 - 접시 -> 함수 -> 스택프레임(접시를 쌓는다.)
// 변수는 알아서 삭제된다.

// 프리스토어 - 스택프레임관느 완전히 독립적인 메모리 공간, 비트 더미
// 직접 삭제해줘야 한다.

struct Employee {
	char firstInitial;
	char lastInitial;
	int employeeNumber;
	int salary{ 75'000 };
};

int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. 포인터 사용법

int main()
{	
	// 프리스토어에 저장하려면 타입에 맞는 메모리 공간을 할당해야 하는데, 이때 포인터를 선언해야한다.
	int* myIntegerPointer;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. 포인터 사용법

int main()
{	
	// 프리스토어에 저장하려면 타입에 맞는 메모리 공간을 할당해야 하는데, 이때 포인터를 선언해야한다.
	int* myIntegerPointer; //초기화하지 않은 변수
	// 포인터 변수는 항상 선언하자마자 초기화해야한다.
	int* myIntegerPointer2{ nullptr };


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. 포인터 사용법

int main()
{	
	// 포인터 변수는 항상 선언하자마자 초기화해야한다.
	int* myIntegerPointer{ nullptr };
	
	// 동적 할당 new
	myIntegerPointer = new int;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. 포인터 사용법

int main()
{	
	// 포인터 변수는 항상 선언하자마자 초기화해야한다.
	int* myIntegerPointer{ nullptr };
	
	// 동적 할당 new
	myIntegerPointer = new int;

	// 공간 해제
	delete myIntegerPointer;
	myIntegerPointer = nullptr;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. 포인터 사용법


struct Employee {
	char firstInitial = 'c';
	char lastInitial = 'j';
	int employeeNumber = 42;
	int salary = 70'000;
};

int main()
{	
	Employee Emp{};
	Employee* anEmployee{ &Emp };
	std::cout << anEmployee->salary << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 3. 동적으로 배열 할당하기


int main()
{	
	int arraySize{ 8 };
	int* myVariableSizedArray{ new int[arraySize] };
	
	myVariableSizedArray[3] = 2;

	delete[] myVariableSizedArray;
	myVariableSizedArray = nullptr;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.26 포인터와 동적메모리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 4. 널 포인터 상수


int main()
{	
	// NULL을 C++11에서는 사용하였는데 NULL은 실제로 상수 0과 같아서 문제가 발생할 여지가 있다.
	// 그렇기에 nullptr을 사용하자 

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. const 상수


const int versionNumberMajor{ 2 };
const int versionNumberMinor{ 1 };
const std::string productName{ "Super Hyper Net Modulator" };
const double PI{ 3.141592 };

int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. const 상수


const int versionNumberMajor{ 2 };
const int versionNumberMinor{ 1 };
const std::string productName{ "Super Hyper Net Modulator" };
const double PI{ 3.141592 };

int main()
{	
	// const 포인터
	const int* ip;
	ip = new int[10];
	//ip[4] = 5; // 컴파일 에러 발생

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. const 상수


const int versionNumberMajor{ 2 };
const int versionNumberMinor{ 1 };
const std::string productName{ "Super Hyper Net Modulator" };
const double PI{ 3.141592 };

int main()
{	
	// const 포인터
	const int* ip; // int const * ip;도 같다.
	ip = new int[10];
	//ip[4] = 5; // 컴파일 에러 발생

	int* const ip2{ nullptr };
	//ip2 = new int[10]; // 컴파일 에러 발생
	//ip2[4] = 5;		   // 에러: 널포인터 역참조

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. const 상수


const int versionNumberMajor{ 2 };
const int versionNumberMinor{ 1 };
const std::string productName{ "Super Hyper Net Modulator" };
const double PI{ 3.141592 };

int main()
{	
	// const 포인터
	const int* ip; // int const * ip;도 같다.
	ip = new int[10];
	//ip[4] = 5; // 컴파일 에러 발생

	int* const ip2{ nullptr };
	//ip2 = new int[10]; // 컴파일 에러 발생
	//ip2[4] = 5;		   // 에러: 널포인터 역참조

	int const* const ip3{ nullptr }; // == const int* const ip3{nullptr}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 1. const 상수

// const 매개변수 
// C++에서는 비 const 변수를 const변수로 캐스트 할 수 있다. 
// 이렇게 하면 다른 코드에서 변수를 변경하지 못하게 보호 할 수 있다.


//void mysteryFunction(const std::string* someString) {
//	*someString = "Test"; // 컴파일 오류
//}

int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 const의 다양한 용도
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 2. const 메서드
// const는 클래스 메서드에도 지정할 수 있다.
// 그러면 해당 클래스의 데이터를 수정할 수 없게 만든다. 수정하려 할시 컴파일 에러가 발생한다.

int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.28 constexpr
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// C++는 상수 표현식(constant expression)이란 것도 제공한다.
// 상수표현식이란 컴파일 시간에 평가되는 표현식이다.

constexpr int getArraySize() { return 32; }

int main()
{	
	int myArray[getArraySize()]; // OK
	int myArray2[getArraySize() + 1]; // OK

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.28 constexpr
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// C++는 상수 표현식(constant expression)이란 것도 제공한다.
// 상수표현식이란 컴파일 시간에 평가되는 표현식이다.

constexpr int getArraySize() { return 32; }

class Rect {
public:
	constexpr Rect(size_t width, size_t height)
		: m_width{width}, m_height{height} { }

	constexpr size_t getArea() const { return m_width * m_height; }
private:
	size_t m_width{ 0 }, m_height{ 0 };
};


int main()
{	
	int myArray[getArraySize()]; // OK
	int myArray2[getArraySize() + 1]; // OK

	// constexpr함수는 C++의 고급기능에 해당한다. 이 책에서는 더 다루지 않는다.

	constexpr Rect r{ 8,2 };
	int myArray3[r.getArea()]; //OK

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 constval 키워드
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// constexpr 키워드는 함수가 컴파일 시간에 실행될 수도 있다고 지정할 뿐
// 반드시 컴파일 시간에 실행되도록 보장하는 것은 아니다.

constexpr double inchToMm(double inch) {
	return inch * 25.4;
}

int main()
{	
	constexpr double const_inch{ 6.0 };
	constexpr double mm1{ inchToMm(const_inch) }; // 컴파일 시간에 평가됨

	double dynamic_inch{ 6.0 };
	double mm2{ inchToMm(dynamic_inch) }; // 컴파일 시간에 평가됨

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 constval 키워드
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// constexpr 키워드는 함수가 컴파일 시간에 실행될 수도 있다고 지정할 뿐
// 반드시 컴파일 시간에 실행되도록 보장하는 것은 아니다.

constexpr double inchToMm(double inch) {
	return inch * 25.4;
}

int main()
{	
	constexpr double const_inch{ 6.0 };
	constexpr double mm1{ inchToMm(const_inch) }; // 컴파일 시간에 평가됨

	double dynamic_inch{ 6.0 };
	double mm2{ inchToMm(dynamic_inch) }; // 실행 시간에 평가됨

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.27 consteval 키워드
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// constexpr 키워드는 함수가 컴파일 시간에 실행될 수도 있다고 지정할 뿐
// 반드시 컴파일 시간에 실행되도록 보장하는 것은 아니다.

// 항상 컴파일 시간에 평가되도록 보장하고 싶다면 C++20에서 제공하는 consteval 키워드로
// 해당 함수를 즉시 실행 함수로 만든다.
consteval double inchToMm(double inch) {
	return inch * 25.4;
}

int main()
{	
	constexpr double const_inch{ 6.0 };
	constexpr double mm1{ inchToMm(const_inch) }; // 컴파일 시간에 평가됨

	//double dynamic_inch{ 6.0 };
	//double mm2{ inchToMm(dynamic_inch) }; // 컴파일 에러

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다.

int main()
{	
	int x{ 3 };
	int& xRef{ x };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다.

int main()
{	
	int x{ 3 };
	int& xRef{ x };

	xRef = 10;
	std::cout << x << std::endl;
	std::cout << xRef << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

int main()
{	
	// 레퍼런스는 처음 초기화할 때 지정한 변수만 가리킨다.
	int x{ 3 }, y{ 4 };
	int& xRef{ x };
	xRef = y; // xRef가 가리키는 대상이 y로 변경되는 것이 아니라 x의 값이 4로 바뀐다.

	//xRef = &y; // 컴파일 에러 발생

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

int main()
{	
	// const 레퍼런스
	int z;
	const int& zRef{ z };
	//zRef = 4; // 컴파일 에러 발생

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

int main()
{	
	// const 레퍼런스
	int z;
	const int& zRef{ z };
	//zRef = 4; // 컴파일 에러 발생
	z = 7; 
	std::cout << zRef << std::endl;
	std::cout << z << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

int main()
{	
	// const 레퍼런스
	int z;
	const int& zRef{ z };
	//zRef = 4; // 컴파일 에러 발생
	z = 7; 
	std::cout << zRef << std::endl;
	std::cout << z << std::endl;

	// int& unnamefRef1{ 5 }; // 컴파일 에러 발생
	const int& unnamedRef2{ 5 }; // 정상 작동

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

std::string getString() { return "Hello world!"; }

int main()
{	
	// const 레퍼런스
	int z;
	const int& zRef{ z };
	//zRef = 4; // 컴파일 에러 발생
	z = 7; 
	std::cout << zRef << std::endl;
	std::cout << z << std::endl;

	// int& unnamefRef1{ 5 }; // 컴파일 에러 발생
	const int& unnamedRef2{ 5 }; // 정상 작동

	//std::string& string1{ getString() };       // 컴파일 에러 발생
	const std::string& string2{ getString() }; // 정상 작동


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

std::string getString() { return "Hello world!"; }

int main()
{	
	// 포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터
	int* intP{ nullptr };
	int*& ptrRef{ intP };
	ptrRef = new int;
	*ptrRef = 5;


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

std::string getString() { return "Hello world!"; }

int main()
{	
	// 포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터
	int* intP{ nullptr };
	int*& ptrRef{ intP };
	ptrRef = new int;
	*ptrRef = 5;

	int x{ 3 };
	int& xRef{ x };
	int* xPtr{ &xRef }; // 레퍼런스의 주소는 값에 대한 포인터와 같다.
	*xPtr = 100;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 1. 레퍼런스 변수 - 레퍼런스 변수는 반드시 생성하자마자 초기화해야한다. 하지 않으면 컴파일 에러 발생

std::string getString() { return "Hello world!"; }

int main()
{	
	// 구조적 바인딩과 레퍼런스

	std::pair myPair{ "hello", 5 };
	auto& [theString, theInt] {myPair};			// 비 const 레퍼런스로 분해
	const auto& [theString2, theInt2] {myPair};	// const 레퍼런스로 분해

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 2. 레퍼런스 데이터 멤버 - 생성자 초기자에서 초기화해야 한다.

class MyClass {
public:
	MyClass(int& ref) : m_ref{ref} {}
private:
	int& m_ref;
};


int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 3. 레퍼런스 매개변수
// 레퍼런스 변수나 레퍼런스 데이터 멤버를 별도로 선언해서 사용하는 일은 많지 않다.
// 레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다.

void addOne(int i) {
	i++; // 복제본이 전달되었기 때문에 원본에는 아무런 영향을 미치지 않는다.
}

void addOne(int& i) {
	i++; // 원본 변수가 변경된다.
}

int main()
{	
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 3. 레퍼런스 매개변수
// 레퍼런스 변수나 레퍼런스 데이터 멤버를 별도로 선언해서 사용하는 일은 많지 않다.
// 레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다.

void swap(int& first, int& second) {
	int temp{ first };
	first = second;
	second = temp;
}

int main()
{
	int x{ 5 }, y{ 6 };
	swap(x, y);

	std::cout << x << "   " << y << std::endl;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 3. 레퍼런스 매개변수
// 레퍼런스 변수나 레퍼런스 데이터 멤버를 별도로 선언해서 사용하는 일은 많지 않다.
// 레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다.

// const 레퍼런스 전달 방식 
// const 레퍼런스 매개변수의 가장 큰 장점은 성능이다. -> 복제본이 아닌 원본에 대한 포인터만 전달
// 또한 const 레퍼런스로 전달시 복제되지도 않고 원본 변수가 변경되지도 않는다.

void printString(const std::string& myString) {
	std::cout << myString << std::endl;
}

int main()
{
	std::string someString{ "Hello World" };
	printString(someString);
	printString("Hello World"); // 리터럴을 전달해도 된다.

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 3. 레퍼런스 매개변수
// 레퍼런스 변수나 레퍼런스 데이터 멤버를 별도로 선언해서 사용하는 일은 많지 않다.
// 레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다.

// const 레퍼런스 전달 방식 
// const 레퍼런스 매개변수의 가장 큰 장점은 성능이다. -> 복제본이 아닌 원본에 대한 포인터만 전달
// 또한 const 레퍼런스로 전달시 복제되지도 않고 원본 변수가 변경되지도 않는다.

// 레퍼런스 전달 방식과 값 전달 방식
// 레퍼런스 전달 방식의 장점
// 효율 - 큰 객체는 복제하는데 시간이 오래 걸릴 수 있다. 하지만 레퍼런스 전달 방식은 개게에 대한 레퍼런스만 함수에 전달된다.
// 지원 - 값 전달 방식을 허용하지 않는 클래스가 있다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 4. 레퍼런스 리턴값 - 함수나 메서드의 리턴값도 레퍼런스 타입으로 지정할 수 있다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

void separateOddsAndEvens(const int arr[], size_t size, int** odds,
	size_t* numOdds, int** evens, size_t* numEvens) {
	// 짝수와 홀수의 개수를 센다.
	*numOdds = *numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++(*numOdds);
		}
		else {
			++(*numEvens);
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	*odds = new int[*numOdds];
	*evens = new int[*numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			(*odds)[oddsPos++] = arr[i];
		}
		else {
			(*evens)[evensPos++] = arr[i];
		}
	}

}



int main()
{
	int unSplit[]{ 1,2,3,4,5,6,7,8,9,10 };
	int* oddNums{ nullptr };
	int* evenNums{ nullptr };
	size_t numOdds{ 0 }, numEvens{ 0 };

	separateOddsAndEvens(unSplit, std::size(unSplit),
		&oddNums, &numOdds, &evenNums, &numEvens);

	// 생성된 배열을 사용하는 코드

	delete[] oddNums; oddNums = nullptr;
	delete[] evenNums; evenNums = nullptr;
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

void separateOddsAndEvens(const int arr[], size_t size, int** odds,
	size_t* numOdds, int** evens, size_t* numEvens) {
	// 짝수와 홀수의 개수를 센다.
	*numOdds = *numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++(*numOdds);
		}
		else {
			++(*numEvens);
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	*odds = new int[*numOdds];
	*evens = new int[*numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			(*odds)[oddsPos++] = arr[i];
		}
		else {
			(*evens)[evensPos++] = arr[i];
		}
	}

}

// 코드가 지저분해지는 것이 싫다면 다음과 같이 레퍼런스 전달 방식으로 구현한다.

void separateOddsAndEvens2(const int arr[], size_t size, int*& odds,
	size_t& numOdds, int*& evens, size_t& numEvens) {
	// 짝수와 홀수의 개수를 센다.
	numOdds = numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++numOdds;
		}
		else {
			++numEvens;
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	odds = new int[numOdds];
	evens = new int[numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			odds[oddsPos++] = arr[i];
		}
		else {
			evens[evensPos++] = arr[i];
		}
	}

}

int main()
{
	int unSplit[]{ 1,2,3,4,5,6,7,8,9,10 };
	int* oddNums{ nullptr };
	int* evenNums{ nullptr };
	size_t numOdds{ 0 }, numEvens{ 0 };

	separateOddsAndEvens(unSplit, std::size(unSplit),
		&oddNums, &numOdds, &evenNums, &numEvens);

	// 생성된 배열을 사용하는 코드

	delete[] oddNums; oddNums = nullptr;
	delete[] evenNums; evenNums = nullptr;
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

void separateOddsAndEvens(const int arr[], size_t size, int** odds,
	size_t* numOdds, int** evens, size_t* numEvens) {
	// 짝수와 홀수의 개수를 센다.
	*numOdds = *numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++(*numOdds);
		}
		else {
			++(*numEvens);
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	*odds = new int[*numOdds];
	*evens = new int[*numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			(*odds)[oddsPos++] = arr[i];
		}
		else {
			(*evens)[evensPos++] = arr[i];
		}
	}

}

// 코드가 지저분해지는 것이 싫다면 다음과 같이 레퍼런스 전달 방식으로 구현한다.

void separateOddsAndEvens2(const int arr[], size_t size, int*& odds,
	size_t& numOdds, int*& evens, size_t& numEvens) {
	// 짝수와 홀수의 개수를 센다.
	numOdds = numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++numOdds;
		}
		else {
			++numEvens;
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	odds = new int[numOdds];
	evens = new int[numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			odds[oddsPos++] = arr[i];
		}
		else {
			evens[evensPos++] = arr[i];
		}
	}

}
//	separateOddsAndEvens2(unSplit, std::size(unSplit),
//	oddNums, numOdds, evenNums, numEvens);

int main()
{
	int unSplit[]{ 1,2,3,4,5,6,7,8,9,10 };
	int* oddNums{ nullptr };
	int* evenNums{ nullptr };
	size_t numOdds{ 0 }, numEvens{ 0 };

	separateOddsAndEvens(unSplit, std::size(unSplit),
		&oddNums, &numOdds, &evenNums, &numEvens);

	// 생성된 배열을 사용하는 코드

	delete[] oddNums; oddNums = nullptr;
	delete[] evenNums; evenNums = nullptr;
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

void separateOddsAndEvens(const int arr[], size_t size, int** odds,
	size_t* numOdds, int** evens, size_t* numEvens) {
	// 짝수와 홀수의 개수를 센다.
	*numOdds = *numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++(*numOdds);
		}
		else {
			++(*numEvens);
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	*odds = new int[*numOdds];
	*evens = new int[*numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			(*odds)[oddsPos++] = arr[i];
		}
		else {
			(*evens)[evensPos++] = arr[i];
		}
	}

}

// 코드가 지저분해지는 것이 싫다면 다음과 같이 레퍼런스 전달 방식으로 구현한다.

void separateOddsAndEvens2(const int arr[], size_t size, int*& odds,
	size_t& numOdds, int*& evens, size_t& numEvens) {
	// 짝수와 홀수의 개수를 센다.
	numOdds = numEvens = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			++numOdds;
		}
		else {
			++numEvens;
		}
	}

	// 새로 만들 두 배열의 크기에 맞게 공간을 할당한다.
	odds = new int[numOdds];
	evens = new int[numEvens];

	// 원본 배열에 담긴 홀수와 짝수 원소를 새로 만들 배열에 복사한다.
	size_t oddsPos = 0, evensPos = 0;
	for (size_t i = 0; i < size; ++i) {
		if (arr[i] % 2 == 1) {
			odds[oddsPos++] = arr[i];
		}
		else {
			evens[evensPos++] = arr[i];
		}
	}

}
//	separateOddsAndEvens2(unSplit, std::size(unSplit),
//	oddNums, numOdds, evenNums, numEvens);

void separateOddsAndEvens3(const std::vector<int>& arr,
	std::vector<int>& odds, std::vector<int>& evens ) {
	
	for (int i : arr) {
		if (i % 2 == 1) {
			odds.push_back(i);
		}
		else {
			evens.push_back(i);
		}
	}

}

int main()
{
	int unSplit[]{ 1,2,3,4,5,6,7,8,9,10 };
	int* oddNums{ nullptr };
	int* evenNums{ nullptr };
	size_t numOdds{ 0 }, numEvens{ 0 };

	separateOddsAndEvens(unSplit, std::size(unSplit),
		&oddNums, &numOdds, &evenNums, &numEvens);

	// 생성된 배열을 사용하는 코드

	delete[] oddNums; oddNums = nullptr;
	delete[] evenNums; evenNums = nullptr;


	std::vector<int> vecUnSplit{ 1,2,3,4,5,6,7,8,9,10 };
	std::vector<int> odds, evens;
	separateOddsAndEvens3(vecUnSplit, odds, evens);
	
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

struct OddsAndEvens { std::vector<int> odds, evens; };

OddsAndEvens separateOddsAndEvens(const std::vector<int>& arr) {
	
	std::vector<int> odds, evens;
	for (int i : arr) {
		if (i % 2 == 1) {
			odds.push_back(i);
		}
		else {
			evens.push_back(i);
		}
	}

	return OddsAndEvens{ .odds = odds, .evens = evens};
}

int main()
{
	// 설명했듯이 결과를 매개변수로 전달하는 방식은 가급적 사용하지 않는 것이 좋다.
	// 함수가 어떤 값을 리턴해야 한다면 출력 매개변수가 아닌 리턴문을 사용한다.
	// return object;와 같이 작성하면 obejct가 로컬 변수거나 함수에 대한 매개변수거나 임시값일 때
	// 리턴값 최적화(RVO)가 적용된다. 또한 object가 로컬 변수라면 이름있는 리턴값 최적화(NRBO)도 적용된다.
	// RVO와 NRVO 둘 다 복제 생략(copy elision)의 한 종류로서, 함수에서 객체를 리턴하는 과정을
	// 굉장히 효율적으로 처리해준다.
	// 복제 생략을 사용하면 컴파일러는 함수에서 리턴하는 객체를 복제하지 않는다.
	// 이를 통해 복제 없는 값 전달 방식을 구현한다.
	
	std::vector<int> vecUnSplit{ 1,2,3,4,5,6,7,8,9,10 };
	auto oddsAndEvens{ separateOddsAndEvens(vecUnSplit) };
	// oddsAndEvens.odds와 oddsAndEvens.evens로 원하는 작업을 수행한다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.30 레퍼런스 - 변수에 대한 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 전문 C++프로그래머가 작성한 코드는 레퍼런스를 상당히 많이 사용한다.
// 변수에 대한 다른 이름(별칭)이라고 생각해도 된다.

// 5. 레퍼런스와 포인터의 선택 기준
// 레퍼런스를 사용하는 것이 코드를 깔끔하고 읽기 쉽게 작성할 수 있다.
// 게다가 포인터보다 훨씬 안전하다.

// 포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.
// 하지만 반드시 포인터를 써야 하는 경우가 있는데 대표적인 예로
// 가리키는 위치를 변경해야 하는 경우를 들수 있다.
// 포인터를 사용하더라도 일반 포인터보다 스마트 포인터를 사용하는 것이 바람직하다.

struct OddsAndEvens { std::vector<int> odds, evens; };

OddsAndEvens separateOddsAndEvens(const std::vector<int>& arr) {
	
	std::vector<int> odds, evens;
	for (int i : arr) {
		if (i % 2 == 1) {
			odds.push_back(i);
		}
		else {
			evens.push_back(i);
		}
	}

	return OddsAndEvens{ .odds = odds, .evens = evens};
}

int main()
{
	// 설명했듯이 결과를 매개변수로 전달하는 방식은 가급적 사용하지 않는 것이 좋다.
	// 함수가 어떤 값을 리턴해야 한다면 출력 매개변수가 아닌 리턴문을 사용한다.
	// return object;와 같이 작성하면 obejct가 로컬 변수거나 함수에 대한 매개변수거나 임시값일 때
	// 리턴값 최적화(RVO)가 적용된다. 또한 object가 로컬 변수라면 이름있는 리턴값 최적화(NRBO)도 적용된다.
	// RVO와 NRVO 둘 다 복제 생략(copy elision)의 한 종류로서, 함수에서 객체를 리턴하는 과정을
	// 굉장히 효율적으로 처리해준다.
	// 복제 생략을 사용하면 컴파일러는 함수에서 리턴하는 객체를 복제하지 않는다.
	// 이를 통해 복제 없는 값 전달 방식을 구현한다.
	
	std::vector<int> vecUnSplit{ 1,2,3,4,5,6,7,8,9,10 };
	auto oddsAndEvens{ separateOddsAndEvens(vecUnSplit) };
	// oddsAndEvens.odds와 oddsAndEvens.evens로 원하는 작업을 수행한다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.31 const_cast()
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// const_cast()는 변수에 const속성을 추가하거나 제거하는 기능을 제공한다.

void ThirdPartyLibraryMethod(char* str){}

void f(const char* str) {
	ThirdPartyLibraryMethod(const_cast<char*> (str));
}

int main()
{
	


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.31 const_cast()
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// const_cast()는 변수에 const속성을 추가하거나 제거하는 기능을 제공한다.

void ThirdPartyLibraryMethod(char* str){}

void f(const char* str) {
	ThirdPartyLibraryMethod(const_cast<char*> (str));
}


int main()
{
	// 표준 라이브러리는 std::as_const()란 헬퍼 메서드를 제공한다.
	// 이 메서드는 <utility> 헤더에 정의되어 있으며, 레퍼런스 매개변수를 const 레퍼런스 버전으로 변환해준다.
	// 기본적으로  as_const(obj) 는 const_cast<const T&>(obj)와 같다. 여기서 T는 obj의 타입이다.

	std::string str{ "C++" };
	const std::string& constStr{ std::as_const(str) };


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.32 입셉션
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// C++의 안전성을 좀 더 높이기 위해 익셉션(exception)이라는 기능을 제공한다.
// 익셉션을 활용하면 문제가 발생했을 때 좀 더 융통성 있게 대처할 수 있다.

double divideNumbers(double numerator, double denominator) {
	if (denominator == 0) {
		throw std::invalid_argument("Denominator cannot be 0.");
	}
	return numerator / denominator;
}

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.06.30 공부
// 1.1.32 입셉션
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <utility>

//import employee;
//import airline_ticket;

#include "save.h"

// C++의 안전성을 좀 더 높이기 위해 익셉션(exception)이라는 기능을 제공한다.
// 익셉션을 활용하면 문제가 발생했을 때 좀 더 융통성 있게 대처할 수 있다.

double divideNumbers(double numerator, double denominator) {
	if (denominator == 0) {
		throw std::invalid_argument("Denominator cannot be 0.");
	}
	return numerator / denominator;
}


int main()
{
	//익셉션이 발생하는 함수를 호출할 때에는 다음 코드처럼 try/catch 블록으로 감싼다.

	try
	{
		std::cout << divideNumbers(2.5, 0.5) << std::endl;
		std::cout << divideNumbers(2.3, 0) << std::endl;
		std::cout << divideNumbers(4.5, 2.5) << std::endl;
	}
	catch (const std::invalid_argument& exception)
	{
		std::cout << std::format("Exception caught: {}", exception.what()) << std::endl;
	}
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.33 타입 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스란 기본에 선언된 타입에 다른 이름을 붙이는 것이다.
// 타입을 새로 정의하지 않고 기존 타입 선언에 대한 동의어를 선언하는 문법이라 생각할 수 있다.

using IntPtr = int*;

int main()
{
	// 두 문장은 같다.
	int* p1;
	IntPtr p2;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.33 타입 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스란 기본에 선언된 타입에 다른 이름을 붙이는 것이다.
// 타입을 새로 정의하지 않고 기존 타입 선언에 대한 동의어를 선언하는 문법이라 생각할 수 있다.

using IntPtr = int*;

int main()
{
	// 두 문장은 같다.
	int* p1 = nullptr;
	IntPtr p2 = nullptr;

	p1 = p2;
	p2 = p1;

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.33 타입 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스란 기본에 선언된 타입에 다른 이름을 붙이는 것이다.
// 타입을 새로 정의하지 않고 기존 타입 선언에 대한 동의어를 선언하는 문법이라 생각할 수 있다.

using IntPtr = int*;

// 타입 앨리어스는 너무 복잡하게 선언된 타입 표현을 좀 더 간편하게 만들기 위한 용도로 많이 사용된다.
// 흔히 템플릿을 이용할 때 이런 경우가 많다.

void processVector(const std::vector<std::basic_string<char>>& vec) { /* 코드 생략 */ }

int main()
{
	// 두 문장은 같다.
	int* p1 = nullptr;
	IntPtr p2 = nullptr;

	p1 = p2;
	p2 = p1;

	std::vector<std::basic_string<char>> myVector;
	processVector(myVector);
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.33 타입 앨리어스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스란 기본에 선언된 타입에 다른 이름을 붙이는 것이다.
// 타입을 새로 정의하지 않고 기존 타입 선언에 대한 동의어를 선언하는 문법이라 생각할 수 있다.

using IntPtr = int*;

// 타입 앨리어스는 너무 복잡하게 선언된 타입 표현을 좀 더 간편하게 만들기 위한 용도로 많이 사용된다.
// 흔히 템플릿을 이용할 때 이런 경우가 많다.
using string = std::basic_string<char>;

void processVector(const std::vector<string>& vec) { /* 코드 생략 */ }

int main()
{
	// 두 문장은 같다.
	int* p1 = nullptr;
	IntPtr p2 = nullptr;

	p1 = p2;
	p2 = p1;

	std::vector<string> myVector;
	processVector(myVector);
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.34 typedef
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스는 C++11부터 도입되어 그 전에는 typedef로 구현해야 했는데 코드가 다소 복잡했다.
typedef int* IntPtr;


int main()
{
	IntPtr p;
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.34 typedef
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 앨리어스는 C++11부터 도입되어 그 전에는 typedef로 구현해야 했는데 코드가 다소 복잡했다.
typedef int* IntPtr;
// typedef보다는 타입 앨리어스를 사용하기를 바란다.

int main()
{
	IntPtr p;
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.


	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.


// auto& - auto를 표현식 타입을 추론하는데 사용하면 레퍼런스와 const가 제거된다.
const std::string message{ "Test" };
const std::string& foo() { return message; }

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.



	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.


// auto& - auto를 표현식 타입을 추론하는데 사용하면 레퍼런스와 const가 제거된다.
const std::string message{ "Test" };
const std::string& foo() { return message; }

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.

	auto f1{ foo() }; // auto == std::string - 값이 복제
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.


// auto& - auto를 표현식 타입을 추론하는데 사용하면 레퍼런스와 const가 제거된다.
const std::string message{ "Test" };
const std::string& foo() { return message; }

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.

	auto f1{ foo() }; // auto == std::string - 값이 복제
	const auto& f2{ foo() }; // 값이 복제되지 않음

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.


// auto& - auto를 표현식 타입을 추론하는데 사용하면 레퍼런스와 const가 제거된다.
const std::string message{ "Test" };
const std::string& foo() { return message; }

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.

	auto f1{ foo() }; // auto == std::string - 값이 복제
	const auto& f2{ foo() }; // 값이 복제되지 않음

	// auto*
	int i{ 123 };
	auto p1{ &i };  // 이렇게 써도 되지만
	auto* p2{ &i }; // 이렇게 명시적으로 드러내게 써주는 것이 좋다.

	const auto* p3{ &i };

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 1.auto
// auto 키워드는 다음과 같이 다양한 상황에 사용한다.
// - 함수의 리턴 타입을 추론한다.
// - 구조적 바인딩에 사용한다.
// - 표현식의 타입을 추론하는데도 사용한다.
// - 비타입 템플릿 매개변수의 타입을 추론하는데 사용한다.
// - 축약 함수 템플릿 구문
// - decltype에서 사용한다.
// - 함수에 대한 또 다른 문법으로 사용한다.
// - 제네릭 람다 표현식에서 사용한다.


// auto& - auto를 표현식 타입을 추론하는데 사용하면 레퍼런스와 const가 제거된다.
const std::string message{ "Test" };
const std::string& foo() { return message; }

int main()
{
	auto x{ 123 }; // x는 int 타입으로 결정된다.

	auto f1{ foo() }; // auto == std::string - 값이 복제
	const auto& f2{ foo() }; // 값이 복제되지 않음

	// auto*
	int i{ 123 };
	auto p1{ &i };  // 이렇게 써도 되지만
	auto* p2{ &i }; // 이렇게 명시적으로 드러내게 써주는 것이 좋다.

	const auto* p3{ &i };

	// 복제 리스트 초기화와 직접 리스트 초기화
	// 복제 리스트 초기화
	auto a = { 11 };		// initializer_list<int>
	auto b = { 11, 22 };    // initializer_list<int>

	// 직접 리스트 초기화
	auto c { 11 };		// initializer_list<int>
	//auto d { 11, 22 };    // initializer_list<int>

	// 복제 리스트 초기화에서 중괄호 안에 나오는 원소는 반드시 타입이 모두 같아야 한다.
	// auto b = { 11,22.33 }; // 컴파일 에러

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.35 타입 추론
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// 타입 추론 - 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
// 타입 추론과 관련된 키워드로 auto와 decltype이 있다.

// 2.decltype 키워드
// 인수로 전달한 표현식의 타입을 알아낸다.

int main()
{
	int x{ 123 };
	decltype(x) y{ 456 };

	// decltype는 레퍼런스나 const 지정자를 삭제하지 않는다는 점에서 auto와 다르다.

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.1.36 표준 라이브러리
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// C++를 사용할 때 표준 라이브러리를 활용하면 C 방식보다 훨씬 쉽고 안전하게 구현할 수 있다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.1 직원 정보 관리 시스템
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// 직원 정보 관리 시스템
// 이 프로그램에서 제공할 기능은 다음과 같다.
// - 직원 채용과 해고
// - 직원 승진과 좌천
// - 과거와 현재의 직원 모두 조회
// - 현재 직원 모두 조회
// - 과거 직원 모두 조회

// 이 프로그램은 크게 세 부분으로 설계한다.
// Employee 클래스는 직원 한명에 대한 정보를 표현한다.
// Database 클래스는 회사에 속한 모든 직원을 관리한다.
// 이 프로그램을 다루는 기능은 UserInterface로 정의한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.2 Employee 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"


// Employee 클래스는 직원 한명에 대한 정보를 표현한다.
// 1. Employee.cppm - Employee 클래스를 정의

int main()
{
	

	save("helloworld.cpp");
	save("employee.cppm");
}

================================================



================================================
////////////////////////////////////////////////////////////////
// employee.cppm
////////////////////////////////////////////////////////////////

export module employee;
import <string>;

namespace Records {
	const int DefalutStartingSalary{ 30'000 };		// 신입 직원에 대한 기본 급여를 정의한다.
	export const int DefalutRaiseAndDemetritAmount{ 1'000 };// 직원 승진과 좌천시 적용할 기본 액수를 정의한다.

	export class Employee {
	public:
		Employee(const std::string& firstName,
			const std::string& laseName);

		void promote(int raiseAmount = DefalutRaiseAndDemetritAmount);
		void demote(int demeritAmount = DefalutRaiseAndDemetritAmount);
		void hire(); // 직원을 재고용한다.
		void fire(); // 직원을 해고한다.
		void display() const; // 직원 정보를 콘솔에 출력한다.

		// getter , setter
		void setFirstName(const std::string& firstName);
		const std::string& getFirstName() const;

		void setLastName(const std::string& lastName);
		const std::string& getLastName() const;

		void setEmployeeNumber(int employeeNumber);
		int getEmployeeNumber() const;

		void setSalary(int newSalary);
		int getSalary() const;

		bool isHired() const;

	private:
		std::string m_firstName;
		std::string m_lastName;
		int m_employeeNumber{ -1 };
		int m_salary{ DefalutStartingSalary };
		bool m_hired{ false };
	};
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.2 Employee 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"


// Employee 클래스는 직원 한명에 대한 정보를 표현한다.
// 2. Employee.cpp

int main()
{
	

	save("helloworld.cpp");
	save("employee.cpp");
}

================================================



================================================
module employee;

using namespace std;

namespace Records {
	Employee::Employee(const string& firstName, const string& lastName)
		: m_firstName{ firstName }, m_lastName{ lastName }
	{
	}

	void Employee::promote(int raiseAmount) {
		setSalary(getSalary() + raiseAmount);
	}

	void Employee::demote(int demeritAmount)
	{
		setSalary(getSalary() - demeritAmount);
	}

	void Employee::hire(){ m_hired = true; }

	void Employee::fire(){ m_hired = false; }

	void Employee::display() const
	{
		cout << format("Employee: {}, {}", getLastName(), getFirstName()) << endl;
		cout << "-------------------------" << endl;
		cout << (isHired() ? "Current Employee" : "Former Employee") << endl;
		cout << format("Employee Number: {}", getEmployeeNumber()) << endl;
		cout << format("Salary: ${}", getSalary()) << endl;
		cout << endl;
	}

	void Employee::setFirstName(const std::string& firstName)
	{
		m_firstName = firstName;
	}

	const std::string& Employee::getFirstName() const
	{
		return m_firstName;
	}

	void Employee::setLastName(const std::string& lastName)
	{
		m_lastName = lastName;
	}

	const std::string& Employee::getLastName() const
	{
		return m_lastName;
	}

	void Employee::setEmployeeNumber(int employeeNumber)
	{
		m_employeeNumber = employeeNumber;
	}

	int Employee::getEmployeeNumber() const
	{
		return m_employeeNumber;
	}

	void Employee::setSalary(int newSalary)
	{
		m_salary = newSalary;
	}

	int Employee::getSalary() const
	{
		return m_salary;
	}

	bool Employee::isHired() const
	{
		return m_hired;
	}

}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.2 Employee 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"


// Employee 클래스는 직원 한명에 대한 정보를 표현한다.
// 2. Employee.cpp

int main()
{
	

	save("helloworld.cpp");
	save("EmployeeTest.cpp");
}

================================================



================================================
import <iostream>;
import employee;

using namespace std;
using namespace Records;

//int main()
//{
//	cout << "Testing the Employee class." << endl;
//	Employee emp{ "Jane", "Doe" };
//	emp.setFirstName("John");
//	emp.setLastName("Doe");
//	emp.setEmployeeNumber(71);
//	emp.setSalary(50'000);
//	emp.promote();
//	emp.promote(50);
//	emp.hire();
//	emp.display();
//}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.2 Employee 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"


// Employee 클래스는 직원 한명에 대한 정보를 표현한다.
// 3. EmployeeTest.cpp

int main()
{
	

	save("helloworld.cpp");
	save("EmployeeTest.cpp");

}

================================================



================================================
import <iostream>;
import employee;

using namespace std;
using namespace Records;

//int main()
//{
//	cout << "Testing the Employee class." << endl;
//	Employee emp{ "Jane", "Doe" };
//	emp.setFirstName("John");
//	emp.setLastName("Doe");
//	emp.setEmployeeNumber(71);
//	emp.setSalary(50'000);
//	emp.promote();
//	emp.promote(50);
//	emp.hire();
//	emp.display();
//}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.3 Database 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// Database 클래스 - 표준 라이브러리에서 제공하는 std::vector 클래스를 이용하여 Employee객체를 저장한다.

int main()
{
	

	save("helloworld.cpp");
	save("Database.cppm");

}

================================================



================================================
export module database;
import <string>;
import <vector>;
import employee;

namespace Records {
	const int FirstEmployeeNumber{ 1'000 };

	export class Database {
	public:
		Employee& addEmployee(const std::string& firstName,
							  const std::string& lastName);
		Employee& getEmployee(int employeeNumber);
		Employee& getEmployee(const std::string& firstName,
							  const std::string& lastName);

		void displayAll() const;
		void displayCurrent() const;
		void displayFormer() const;

	private:
		std::vector<Employee> m_employees;
		int m_nextEmployeeNumber{ FirstEmployeeNumber };
	};
}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.3 Database 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// Database 클래스 - 표준 라이브러리에서 제공하는 std::vector 클래스를 이용하여 Employee객체를 저장한다.

int main()
{
	

	save("helloworld.cpp");
	save("Database.cppm");

}

================================================



================================================
////////////////////////////////////////////////////////////////
// Database.cppm
////////////////////////////////////////////////////////////////

export module database;
import <string>;
import <vector>;
import employee;

namespace Records {
	const int FirstEmployeeNumber{ 1'000 };

	export class Database {
	public:
		Employee& addEmployee(const std::string& firstName,
							  const std::string& lastName);
		Employee& getEmployee(int employeeNumber);
		Employee& getEmployee(const std::string& firstName,
							  const std::string& lastName);

		void displayAll() const;
		void displayCurrent() const;
		void displayFormer() const;

	private:
		std::vector<Employee> m_employees;
		int m_nextEmployeeNumber{ FirstEmployeeNumber };
	};
}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.3 Database 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// Database 클래스 - 표준 라이브러리에서 제공하는 std::vector 클래스를 이용하여 Employee객체를 저장한다.

int main()
{
	

	save("helloworld.cpp");
	save("Database.cpp");

}

================================================



================================================
////////////////////////////////////////////////////////////////
// Database.cpp
////////////////////////////////////////////////////////////////

module database;
//import <stdexcept>;

using namespace std;

namespace Records {
	Employee& Database::addEmployee(const string& firstName,
									const string& lastName) {
		Employee theEmployee{ firstName, lastName };
		theEmployee.setEmployeeNumber(m_nextEmployeeNumber++);
		theEmployee.hire();
		m_employees.push_back(theEmployee);
		return m_employees.back();
	}
	Employee& Database::getEmployee(int employeeNumber)
	{
		for (auto& employee : m_employees) {
			if (employee.getEmployeeNumber() == employeeNumber) {
				return employee;
			}
		}
		throw logic_error{ "No employee found. " };
	}
	Employee& Database::getEmployee(const std::string& firstName, const std::string& lastName)
	{
		for (auto& employee : m_employees) {
			if (employee.getFirstName() == firstName && employee.getLastName() == lastName) {
				return employee;
			}
		}
		throw logic_error{ "No employee found" };
	}
	void Database::displayAll() const
	{
		for (const auto& employee : m_employees) { employee.display(); }
	}
	void Database::displayCurrent() const
	{
		for (const auto& employee : m_employees) {
			if (employee.isHired()) { employee.display(); }
		}
	}
	void Database::displayFormer() const
	{
	}
}================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.3 Database 클래스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <format>
#include <vector>
#include <initializer_list>

//import employee;
//import airline_ticket;

#include "save.h"

// 3. DatabseTest.cpp

int main()
{
	

	save("helloworld.cpp");
	save("DatabaseTest.cpp");

}

================================================



================================================
////////////////////////////////////////////////////////////////
// DatabaseTest.cpp
////////////////////////////////////////////////////////////////

import <iostream>;
import database;

using namespace std;
using namespace Records;

//int main()
//{
//	Database myDB;
//	Employee& emp1{ myDB.addEmployee("Greg", "Wallis") };
//	emp1.fire();
//
//	Employee& emp2{ myDB.addEmployee("Marc", "White") };
//	emp2.setSalary(100'000);
//
//	Employee& emp3{ myDB.addEmployee("John", "Doe") };
//	emp2.setSalary(10'000);
//	emp3.promote();
//
//	cout << "all employees: " << endl << endl;
//	myDB.displayAll();
//
//	cout << endl << "current employees: " << endl << endl;
//	myDB.displayCurrent();
//
//	cout << endl << "former employees: " << endl << endl;
//	myDB.displayFormer();
//}
================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.4 사용자 인터페이스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <stdexcept>
#include <exception>
#include <string>
#include <format>

import database;
import employee;

//import airline_ticket;

#include "save.h"

using namespace std;
using namespace Records;

int displayMenu();
void doHire(Database& db);
void doFire(Database& db);
void doPromote(Database& db);

int main()
{
	Database employeeDB;
	bool done{ false };
	while (!done) {
		int selection{ displayMenu() };
		switch (selection)
		{
		case 0:
			done = true;
			break;
		case 1:
			doHire(employeeDB);
			break;
		case 2:
			doFire(employeeDB);
			break;
		case 3:
			doPromote(employeeDB);
			break;
		case 4:
			employeeDB.displayAll();
			break;
		case 5:
			employeeDB.displayCurrent();
			break;
		case 6:
			employeeDB.displayFormer();
			break;
		default:
			cerr << "Unkown command. " << endl;
			break;
		}
	}




	save("helloworld.cpp");

}

// 메뉴를 화면에 출력하고, 사용자로부터 입력을 받는다.
int displayMenu() {
	int selection;
	cout << endl;
	cout << "Employee Database" << endl;
	cout << "-----------------" << endl;
	cout << "1) Hire a new employee" << endl;
	cout << "2) Fire an employee" << endl;
	cout << "3) Promote an employee" << endl;
	cout << "4) List all employee" << endl;
	cout << "5) List all current employee" << endl;
	cout << "6) List all former employee" << endl;
	cout << "0) Quit" << endl;
	cout << endl;
	cout << "---> ";
	cin >> selection;
	return selection;
}

// 사용자로부터 신입 직원의 이름을 입력받아서 데이터베이스에
// 그 직원에 대한 정보를 추가하도록 요청한다.
void doHire(Database& db) {
	string firstName;
	string lastName;

	cout << "First name? ";
	cin >> firstName;

	cout << "Last name? ";
	cin >> lastName;

	auto& employee{ db.addEmployee(firstName, lastName) };
	cout << format("Hired employee {} {} with employee number {}.",
		firstName, lastName, employee.getEmployeeNumber()) << endl;

}

void doFire(Database& db) {
	int employeeNumber;
	cout << "Employee number?";
	cin >> employeeNumber;

	try {
		auto& emp{ db.getEmployee(employeeNumber) };
		emp.fire();
		cout << format("Employee {} terminated.", employeeNumber) << endl;
	}
	catch(const std::logic_error& exception)
	{
		cerr << format("Unable to terminate employee: {}", exception.what()) << endl;
	}
}
void doPromote(Database& db) {
	int employeeNumber;
	cout << "Employee number? ";
	cin >> employeeNumber;

	int raiseAmount;
	cout << "How much of a raise? ";
	cin >> raiseAmount;

	try {
		auto& emp{ db.getEmployee(employeeNumber) };
		emp.promote(raiseAmount);
	}
	catch (const std::logic_error& exception) {
		cerr << format("Unable to promote employee: {}", exception.what()) << endl;
	}
}
================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.2 어느 정도 규모 있는 첫 C++프로그램
// 1.2.4 사용자 인터페이스
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <stdexcept>
#include <exception>
#include <string>
#include <format>

import database;
import employee;

//import airline_ticket;

#include "save.h"

using namespace std;
using namespace Records;

int displayMenu();
void doHire(Database& db);
void doFire(Database& db);
void doPromote(Database& db);

int main()
{
	Database employeeDB;
	bool done{ false };
	while (!done) {
		int selection{ displayMenu() };
		switch (selection)
		{
		case 0:
			done = true;
			break;
		case 1:
			doHire(employeeDB);
			break;
		case 2:
			doFire(employeeDB);
			break;
		case 3:
			doPromote(employeeDB);
			break;
		case 4:
			employeeDB.displayAll();
			break;
		case 5:
			employeeDB.displayCurrent();
			break;
		case 6:
			employeeDB.displayFormer();
			break;
		default:
			cerr << "Unkown command. " << endl;
			break;
		}
	}




	save("helloworld.cpp");

}

// 메뉴를 화면에 출력하고, 사용자로부터 입력을 받는다.
int displayMenu() {
	int selection;
	cout << endl;
	cout << "Employee Database" << endl;
	cout << "-----------------" << endl;
	cout << "1) Hire a new employee" << endl;
	cout << "2) Fire an employee" << endl;
	cout << "3) Promote an employee" << endl;
	cout << "4) List all employee" << endl;
	cout << "5) List all current employee" << endl;
	cout << "6) List all former employee" << endl;
	cout << "0) Quit" << endl;
	cout << endl;
	cout << "---> ";
	cin >> selection;
	return selection;
}

// 사용자로부터 신입 직원의 이름을 입력받아서 데이터베이스에
// 그 직원에 대한 정보를 추가하도록 요청한다.
void doHire(Database& db) {
	string firstName;
	string lastName;

	cout << "First name? ";
	cin >> firstName;

	cout << "Last name? ";
	cin >> lastName;

	auto& employee{ db.addEmployee(firstName, lastName) };
	cout << format("Hired employee {} {} with employee number {}.",
		firstName, lastName, employee.getEmployeeNumber()) << endl;

}

void doFire(Database& db) {
	int employeeNumber;
	cout << "Employee number?";
	cin >> employeeNumber;

	try {
		auto& emp{ db.getEmployee(employeeNumber) };
		emp.fire();
		cout << format("Employee {} terminated.", employeeNumber) << endl;
	}
	catch(const std::logic_error& exception)
	{
		cerr << format("Unable to terminate employee: {}", exception.what()) << endl;
	}
}
void doPromote(Database& db) {
	int employeeNumber;
	cout << "Employee number? ";
	cin >> employeeNumber;

	int raiseAmount;
	cout << "How much of a raise? ";
	cin >> raiseAmount;

	try {
		auto& emp{ db.getEmployee(employeeNumber) };
		emp.promote(raiseAmount);
	}
	catch (const std::logic_error& exception) {
		cerr << format("Unable to promote employee: {}", exception.what()) << endl;
	}
}
================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.3 정리
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

// 지금까지 소개한 C++와 표준 라이브러리의 기초를 제대로 익혔다면
// 전문가 수준의 C++프로그래머로 넘어갈 준비가 되었다.


int main()
{


	save("helloworld.cpp");

}
================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"


// 연습문제 1-1
namespace HR {
	struct Employee {
		char firstInitial;
		char lastInitial;
		int employeeNumber;
		int salary{ 75'000 };
	};
}

int main()
{
	HR::Employee anEmployee{
	.firstInitial = 'J',
	.lastInitial = 'D',
	.employeeNumber = 42,
	.salary = 80'000
	};
	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"


// 연습문제 1-2

enum class title {
	Aclass,
	Bclass,
	Cclass,
};

namespace HR {
	struct Employee {
		char firstInitial;
		char lastInitial;
		int employeeNumber;
		int salary{ 75'000 };
		title t{ title::Aclass };
	};
}

int main()
{
	HR::Employee anEmployee{
	.firstInitial = 'J',
	.lastInitial = 'D',
	.employeeNumber = 42,
	.salary = 80'000
	};

	anEmployee.t;
	
	switch (anEmployee.t)
	{
	case title::Aclass:
		std::cout << "AClass" << std::endl;
		break;

	case title::Bclass:
		std::cout << "BClass" << std::endl;
		break;

	case title::Cclass:
		std::cout << "CClass" << std::endl;
		break;
	default:
		break;
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <array>

//import database;
//import employee;

//import airline_ticket;

#include "save.h"


// 연습문제 1-3

enum class title {
	Aclass,
	Bclass,
	Cclass,
};

namespace HR {
	struct Employee {
		char firstInitial;
		char lastInitial;
		int employeeNumber;
		int salary{ 75'000 };
		title t{ title::Aclass };
	};
}

int main()
{
	HR::Employee anEmployee{
	.firstInitial = 'J',
	.lastInitial = 'D',
	.employeeNumber = 42,
	.salary = 80'000
	};

	HR::Employee anEmployee2{
		.firstInitial = 'Q',
		.lastInitial = 'R',
		.employeeNumber = 48,
		.salary = 50'000,
		.t = title::Bclass
	};
	
	HR::Employee anEmployee3{
		.firstInitial = 'Y',
		.lastInitial = 'A',
		.employeeNumber = 49,
		.salary = 30'000,
		.t = title::Cclass
	};

	std::array<HR::Employee, 3> arrEmp;

	arrEmp[0] = anEmployee;
	arrEmp[1] = anEmployee2;
	arrEmp[2] = anEmployee3;

	for (auto& employee : arrEmp) {
		std::cout << employee.employeeNumber << std::endl;
		std::cout << employee.firstInitial << std::endl;
		std::cout << employee.lastInitial << std::endl;
		std::cout << employee.salary << std::endl;
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <array>

//import database;
//import employee;

//import airline_ticket;

#include "save.h"


// 연습문제 1-3

enum class title {
	Aclass,
	Bclass,
	Cclass,
};

namespace HR {
	struct Employee {
		char firstInitial;
		char lastInitial;
		int employeeNumber;
		int salary{ 75'000 };
		title t{ title::Aclass };
	};
}

int main()
{
	HR::Employee anEmployee{
	.firstInitial = 'J',
	.lastInitial = 'D',
	.employeeNumber = 42,
	.salary = 80'000
	};

	HR::Employee anEmployee2{
		.firstInitial = 'Q',
		.lastInitial = 'R',
		.employeeNumber = 48,
		.salary = 50'000,
		.t = title::Bclass
	};
	
	HR::Employee anEmployee3{
		.firstInitial = 'Y',
		.lastInitial = 'A',
		.employeeNumber = 49,
		.salary = 30'000,
		.t = title::Cclass
	};

	std::array<HR::Employee, 3> arrEmp;

	arrEmp[0] = anEmployee;
	arrEmp[1] = anEmployee2;
	arrEmp[2] = anEmployee3;

	for (auto& employee : arrEmp) {
		std::cout << "=======================" << std::endl;
		std::cout << employee.employeeNumber << std::endl;
		std::cout << employee.firstInitial << std::endl;
		std::cout << employee.lastInitial << std::endl;
		std::cout << employee.salary << std::endl;
		std::cout << "=======================" << std::endl;
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>

//import database;
//import employee;

//import airline_ticket;

#include "save.h"


// 연습문제 1-3

enum class title {
	Aclass,
	Bclass,
	Cclass,
};

namespace HR {
	struct Employee {
		char firstInitial;
		char lastInitial;
		int employeeNumber;
		int salary{ 75'000 };
		title t{ title::Aclass };
	};
}

int main()
{
	HR::Employee anEmployee{
	.firstInitial = 'J',
	.lastInitial = 'D',
	.employeeNumber = 42,
	.salary = 80'000
	};

	HR::Employee anEmployee2{
		.firstInitial = 'Q',
		.lastInitial = 'R',
		.employeeNumber = 48,
		.salary = 50'000,
		.t = title::Bclass
	};
	
	HR::Employee anEmployee3{
		.firstInitial = 'Y',
		.lastInitial = 'A',
		.employeeNumber = 49,
		.salary = 30'000,
		.t = title::Cclass
	};

	std::vector<HR::Employee> vecEmp;

	vecEmp.push_back(anEmployee);
	vecEmp.push_back(anEmployee2);
	vecEmp.push_back(anEmployee3);

	for (auto& employee : vecEmp) {
		std::cout << "=======================" << std::endl;
		std::cout << employee.employeeNumber << std::endl;
		std::cout << employee.firstInitial << std::endl;
		std::cout << employee.lastInitial << std::endl;
		std::cout << employee.salary << std::endl;
		std::cout << "=======================" << std::endl;
	}

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>

//import database;
//import employee;

import airline_ticket;

#include "save.h"


// 연습문제 1-6


int main()
{
	

	save("helloworld.cpp");
	save("airlinetickettest.cpp");
}

================================================



================================================
////////////////////////////////////////////////////////////////
// airlinetickettest.cppm
////////////////////////////////////////////////////////////////

import airline_ticket;
import <iostream>;
import <format>;

using namespace std;

//int main()
//{
//	AirlineTicket myTicket;  // Stack-based AirlineTicket
//	myTicket.setPassengerName("Sherman T. Socketwrench");
//	myTicket.setNumberOfMiles(700);
//	myTicket.setFrequentFlyerNumber(123'456);
//	double cost{ myTicket.calculatePriceInDollars() };
//	cout << format("This ticket will cost ${}", cost);
//
//	auto frequentFlyerNumber{ myTicket.getFrequentFlyerNumber() };
//	if (frequentFlyerNumber) {
//		cout << format("Frequent flyer number: {}", frequentFlyerNumber.value());
//	}
//	else {
//		cout << "No frequent flyer number.";
//	}
//}
================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.01 공부
// 1.4 연습문제
/////////////////////////////////////////////////////////////////

#include <iostream>
#include <vector>

//import database;
//import employee;

import airline_ticket;

#include "save.h"


// 연습문제 1-6


int main()
{
	
	save("helloworld.cpp");
}

// Chapter1 C++와 표준 라이브러리 초단기 속성 코스 完
================================================
