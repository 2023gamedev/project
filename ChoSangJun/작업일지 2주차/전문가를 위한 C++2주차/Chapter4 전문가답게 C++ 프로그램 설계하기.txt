


================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 본격적으로 코드를 작성하기 전에 반드시 프로그램 설계부터 해야 한다.
// 특히 팀 단위로 프로그램을 작성할 때는 사용할 데이터 구조나 클래스에 대한 분석 작업부터 먼저 한다.
// 이 장에서는 C++프로그램을 전문가답게 설계하는 방법을 소개한다.

int main()
{

	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.1 프로그램 설계의 정의
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 가장 먼저 할 일은 요구사항을 분석하는 것이다.
// 그렇기 위해서는 이해 당사자와 함께 논의해야 한다.
// 요구사항 분석 단계의 핵심 결과물은 기능 요구사항 문서다.
// 이 문서는 작성할 코드가 정확히 할 일만 표현하고, 이를 달성하는 방법은 생략한다.
// 또한 이 단계에서 최종 시스템의 동작이 아닌 속성을 표현하는 비기능 요구사항 문서도 나올 수 있다.
// 예를 들어 시스템이 보안에 뛰어나고, 확장성도 높고, 일정한 성능 기준을 만족해야 한다는 표현도 여기에 적는다.

// 요구사항을 모두 수집했다면 프로그램 설계 단계로 넘어갈 수 있다. 프로그램 설계란
// 앞 단계에서 도출한 요구사항을 모두 만족하는 프로그램을 구현하기 위한 명세서다.
// 쉽게 말해 프로그램의 구현 계획을 정리한 것이다. 대부분 크게 두 부분으로 구성된다.
// - 프로그램을 구성하는 서브시스템 : 인터페이스와 서브시스템 사이의 의존성, 서브시스템 사이의 데이터 흐름,
//		서브시스템에 대한 입력과 출력, 기본 스레드 활용 모델
// - 서브시스템 세부사항 : 클래스 구성, 클래스 계층도, 데이터 구조, 알고리즘, 개별 스레드 활용 모델, 에러 처리 방법

// 설계 문서는 대체로 서브시스템 사이의 상호 작용과 클래스 계층을 보여주는 다이어그램이나 표로 구성된다.

// 코드 작성에 들어가기 전에 최대한 설계를 잘해야 한다. 설계는 프로그램에 대한 지도 역할을 한다.



int main()
{

	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.2 프로그램 설계의 중요성
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 요구사항 분석과 설계과정을 건너뛰거나 가볍게 넘기고 빨리 프로그래밍 단계로 넘어가려는 유혹에 빠지기 쉽다.
// 코드를 컴파일해서 실행하면 일이 진행된다는 느낌이 확실히 들기 때문이다.
// 하지만 설계 과정을 거치지 않고도 제대로 구현하려면 프로그래밍 경험이 풍부하고,
// 주요 설계 패턴도 자유자재로 적용할 수 있어야 하고, C++뿐만 아니라 주어진 문제의 배경과 요구사항을
// 깊이 이해해야 한다.

// 설계 단계를 거치지 않으면 서브시스템 사이의 관계와 재사용 가능성, 공유 정보 그리고 주어진 작업을 처리하기 위한
// 가장 쉬운 방법 등을 놓치기 쉽다. 이렇게 설계를 통해 '큰 그림'을 보는 과정이 없으면 사소한 구현 세부사항에 빠져
// 전체 구조와 목적을 놓치기 쉽다. 이후에는 체스 예제를 통해 설명하나 너무 길어 생략했다.


int main()
{

	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.3 C++에 적합한 설계방법
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// C++ 프로그램을 설계할 때 다음과 같은 C++언어의 특성을 반드시 명심한다.
// - C++에서 제공하는 기능은 방대하다.
// - C++는 객체지향 언어다.
// - C++는 코드의 범용성과 재사용성을 높이는 데 필요한 기능을 다양하게 제공한다.
// - C++는 여러가지 유용한 표준 라이브러리를 제공한다.
// - C++는 다양한 설계 패턴을 곧바로 적용하기 좋다.

// 설계 작업은 만만치 않다. 필자는 하루 종일 설계안을 고민하여 종이에 끄적였다갓 지우고,
// 새로운 아이디어를 추가했다가 지우는 과정을 수없이 반복한다.
// 중간에 막혀서 진척이 없다면 다음과 같은 방법을 취한다.
// - 도움을 요청한다.
// - 잠시 다른 일에 몰두한다.
// - 일단 결정을 내리고 다음 단계로 나아간다.


int main()
{

	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.4 C++ 설계에 관련된 두가지 원칙
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// C++ 설계에서 가장 핵심적인 규칙은 추상화와 재사용이다.
// 이 책뿐만 아니라 거의 모든 자료에서 C++프로그램을 효과적으로 설계하는 방법을 소개할 때마다
// 항상 등장하는 주제다.


int main()
{

	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.4 C++ 설계에 관련된 두가지 원칙
// 4.4.1 추상화
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// C++ 설계에서 가장 핵심적인 규칙은 추상화와 재사용이다.
// 이 책뿐만 아니라 거의 모든 자료에서 C++프로그램을 효과적으로 설계하는 방법을 소개할 때마다
// 항상 등장하는 주제다.


// 추상화 원칙은 현실 상황에 비유하면 이해하기 쉽다.
// TV를 켜거나 끄는 방법, 볼륨을 조절하는 방법과 같은 TV기능은 누구나 알 것이다.
// 하지만 TV 상자 내부에서 벌어지는 구체적인 작동 원리에 대해 설명하기는 쉽지 않다.
// 하지만 몰라도 사용하는데는 문제가 없다. TV의 내부 구현과 외부 인터페이스가 명확히 분리되어 있기 때문이다.





int main()
{
	// [1] 추상화의 장점
	// 소프트웨어에 적용되는 추상화 원칙도 이와 비슷하다.
	// 내부 구현 방식을 몰라도 코드를 사용할 수 있다.
	cout << "This call will display this line of text" << endl;
	// 이때 cout이 주어진 문자 배열을 사용자의 화면에 출력하는 과정은 몰라도 된다.

	
	// [2] 추상화를 적용하여 설계하기
	// 함수와 클래스를 설계할 때는 작성자 자신뿐만 아니라 다른 프로그래머가 내부 구현사항을 몰라도
	// 쉽게 사용할 수 있게 구성해야 한다. 체스 프로그램을 살펴보자.
	/*
	ChessPiece* chessBoard[8][8]{};
	...
	chessBoard[0][0] new Rock{};
	
	// 하지만 이렇게 하면 추상화 원칙에 어긋난다. 체스보드를 사용하는 프로그래머는 항상 체스보드가 2차원 배열로
	// 구현되었다는 사실을 알아야 한다. 또한 체스보드를 사용하는 측에서 메모리 조작 과정에 문제가 발생하지 않도록 직접 관리해야 한다.
	// 이렇게 되면 인터페이스와 구현이 확실히 분리되었다고 볼 수 없다.

	// 이보다 나은 방법은 체스보드 모델을 클래스로 작성하는 것이다.
	class ChessBoard {
	public:
		void setPieceAt(size_t x, size_t y, ChessPiece* piece);
		ChessPiece* getPieceAt(size_t x, size_t y) const;
		bool isEmpty(size_t x, size_t y) const;
	private:
		// 데이터 멤버 코드 생략
	};
	*/
	// 이 인터페이스를 보면 내부 구현에 대한 코드는 한줄도 없다. CheesBoard를 2차원 배열로 구현하더라도
	// 인터페이스에 전혀 어긋나지 않는다. 구현 방식이 바뀌더라도 인터페이스를 그대로 유지할 수 있다.

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.4 C++ 설계에 관련된 두가지 원칙
// 4.4.2 재사용
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// C++ 설계에서 가장 핵심적인 규칙은 추상화와 재사용이다.
// 이 책뿐만 아니라 거의 모든 자료에서 C++프로그램을 효과적으로 설계하는 방법을 소개할 때마다
// 항상 등장하는 주제다.


// C++ 설계에서 두 번째로 중요한 원칙은 재사용이다. 이 원칙도 현실세계에 비유하면 이해하기 쉽다.
// 빵집 출근 첫날 수석제빵사가 쿠키를 굽는 작업을 맡겼다. 임무를 완수하기 위해 쿠키에 대한 레시피를 찾아보고
// 재료를 잘 조합해 오븐에 집어넣었다. 그랬더닌 수석제빵사가 흡족해했다.
// 여기서 당연하지만 지나치기 쉬운 사실이 있는데 오븐은 직접 만들지 않았다는 것이다.
// 버터나 밀가루, 초콜릿 칩도 직접 만들지 않았다. 빵집입장이 아닌 프로그래밍 시각으로 보면
// 다른사람이 이미 만든 오븐코드를 사용하는 것이라 볼 수 있다. 레시피도 마찬가지이다.
// 당연하다고 생각되지만 C++ 프로그래밍 세계에서는 그렇지 않다. 중복 구현하는 C++ 프로그래머들이 많은 것이 현실이다.

// 안타깝게도 기존 코드를 제대로 활용하지 않는 프로그래머가 많다. 설계할 때 기존 코드가 있다면 이를 재사용할 수 있는지
// 반드시 검토하기 바란다.


// [1] 재사용 가능한 코드 만들기
// C++는 코드를 범용으로 만들 수 있도록 템플릿이라는 기능을 제공한다.
// 앞에 나온 ChessBoard를 2차원 보드를 사용하는 게임이라면 언제든지 적용할 수 있도록
// GameBoard라는 제네릭(범용) 클래스 템플릿으로 정의한다. 자세한 문법은 나중에 설명하겠다.
/*
template <typename Piecetype>
class GameBoard {
public:
	void setPieceAt(size_t x, size_t y, PieceType* piece);
	Piecetype* getPieceAt(size_t x, size_t y) const;
	bool isEmpty(size_t x, size_t y) const;
private:
	// 코드 생략
};
*/
// 이렇게 인터페이스를 살짝 변경하는 것만으로도 2차원 보드를 사용하는 게임이라면 어디서나 적용할 수 있는
// 범용 게임 보드 클래스를 만들 수 있다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.4 C++ 설계에 관련된 두가지 원칙
// 4.4.2 재사용
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// C++ 설계에서 가장 핵심적인 규칙은 추상화와 재사용이다.
// 이 책뿐만 아니라 거의 모든 자료에서 C++프로그램을 효과적으로 설계하는 방법을 소개할 때마다
// 항상 등장하는 주제다.


// C++ 설계에서 두 번째로 중요한 원칙은 재사용이다. 이 원칙도 현실세계에 비유하면 이해하기 쉽다.
// 빵집 출근 첫날 수석제빵사가 쿠키를 굽는 작업을 맡겼다. 임무를 완수하기 위해 쿠키에 대한 레시피를 찾아보고
// 재료를 잘 조합해 오븐에 집어넣었다. 그랬더닌 수석제빵사가 흡족해했다.
// 여기서 당연하지만 지나치기 쉬운 사실이 있는데 오븐은 직접 만들지 않았다는 것이다.
// 버터나 밀가루, 초콜릿 칩도 직접 만들지 않았다. 빵집입장이 아닌 프로그래밍 시각으로 보면
// 다른사람이 이미 만든 오븐코드를 사용하는 것이라 볼 수 있다. 레시피도 마찬가지이다.
// 당연하다고 생각되지만 C++ 프로그래밍 세계에서는 그렇지 않다. 중복 구현하는 C++ 프로그래머들이 많은 것이 현실이다.

// 안타깝게도 기존 코드를 제대로 활용하지 않는 프로그래머가 많다. 설계할 때 기존 코드가 있다면 이를 재사용할 수 있는지
// 반드시 검토하기 바란다.


// [1] 재사용 가능한 코드 만들기
// C++는 코드를 범용으로 만들 수 있도록 템플릿이라는 기능을 제공한다.
// 앞에 나온 ChessBoard를 2차원 보드를 사용하는 게임이라면 언제든지 적용할 수 있도록
// GameBoard라는 제네릭(범용) 클래스 템플릿으로 정의한다. 자세한 문법은 나중에 설명하겠다.
/*
template <typename Piecetype>
class GameBoard {
public:
	void setPieceAt(size_t x, size_t y, PieceType* piece);
	Piecetype* getPieceAt(size_t x, size_t y) const;
	bool isEmpty(size_t x, size_t y) const;
private:
	// 코드 생략
};
*/
// 이렇게 인터페이스를 살짝 변경하는 것만으로도 2차원 보드를 사용하는 게임이라면 어디서나 적용할 수 있는
// 범용 게임 보드 클래스를 만들 수 있다.


// [2] 설계 재사용
// C++ 언어를 익히는 것과 뛰어나 C++프로그래머가 되는 것은 전혀 별개다.
// 자리에 앉아 C++ 표준을 읽고 세세한 사항을 암기하는 것은 누구나 할 수 있다.
// 하지만 코드를 읽고 프로그램을 직접 작성해본 경험이 어느 정도 쌓이기 전에는 결코 뛰어나 프로그래머가 될 수 없다.

// C++ 언어에 대한 경험이 쌓일수록 언어에서 제공하는 기능에 대한 자신만의 활용법을 터득하게 된다.
// 이 책에서는 설계 기법과 설계 패턴(디자인 패턴)이라고 부르는 언어의 재사용 기법을 여러차례 강조한다.

// 주어진 설계 문제에 어떤 해결책을 적용할지 판단하려면 여러 가지 패턴과 기법을 잘 익혀둬야 한다.





int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.5 코드 재사용
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 경험이 풍부한 C++프로그래머라면 프로젝트를 구성하는 코드를 무작정 처음부터 새로 만들지 않는다.
// 표준 라이브러리, 오픈소스 라이브러리, 회사에서 구매한 상용코드, 예전 프로젝트에서 작성했던 코드를 비롯한
// 다양한 소스를 최대한 활용한다. 그러기 위해서는 코드를 프로젝트에 맞게 자유자재로 활용할 수 있어야 한다.
// 이 원칙을 극대화하려면 재사용 가능한 코드의 형태와 코드 재사용의 장단점을 명확히 이해해야 한다.






int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.5.1 용어 정리
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 재사용 가능한 코드는 다음과 같이 세가지로 구분할 수 있다.
// - 예전에 자신이 작성했던 코드
// - 동료가 작성한 코드
// - 현재 소속 회사나 조직 외의 서드파티에서 작성한 코드

// 재사용할 코드의 형태도 다음과 같이 다양하다.
// - 독립 함수 또는 클래스
// - 라이브러리
// - 프레임워크
// - 애플리케이션

// API란 용어도 자주 사용한다. API는 특정한 기능을 수행하는 코드나 라이브러리에 대한 인터페이스를 말한다.






int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.5.2 코드 재사용의 판단 기준
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;


// [1] 코드 재사용 장점 (너무 길어 다 적지는 못하고 축약해서 적어보았다.)
// 코드 재사용은 개발자뿐만 아니라 프로젝트 입장에서 다음과 같은 엄청난 장점이 있다.
// - 필요한 코드를 작성하는 방법을 모르거나 작성에 걸리는 시간을 가늠하기 힘들 때 
// - 재사용한 코드로 구현할 컴포넌트에 대한 설계가 필요 없기 때문에 설계 과정이 간결해진다.
// - 재사용한 코드는 대부분 디버깅할 필요가 없다.
// - 라이브러리는 다양한 에러 상황에 대응하는 능력이 여러분이 직접 처음부터 작성한 코드보다 훨씬 뛰어나다.
// - 라이브러리는 다양한 플랫폼에 대해 테스트를 거친 것이 많다.
// - 라이브러리는 대체로 사용자가 값을 잘못 입력할 때에도 적절히 대처한다.
// - 자신이 직접 작성한 코드보다 해당 분야의 전문가가 작성한 코드를 사용하는 것이 훨씬 안전하다.
// - 라이브러리는 지속적으로 개선된다.


// [2] 코드 재사용 단점
// - 라이브러리에서 제공하는 인터페이스를 파악하고 올바른 사용법을 익히는데 시간이 걸린다.
// - 라이브러리에서 제공하는 기능이 자신이 원하는 바와 정확히 일치하지 않을 수 있다.
// - 라이브러리에서 자신이 원하는 기능을 정확히 제공하더라도 원하는 만큼 성능이 나오지 않을 수도 있다.
// - 라이브러리 코드를 사용하면 유지 보수에 문제가 발생할 수 있다.
// - 라이브러리를 사용하면 유지 보수 문제뿐만 아니라 라이선스 문제도 발생할 수 있다.
// - 재사용할 코드를 신뢰할 수 있어야 한다.
// - 라이브러리를 새 버전으로 업그레이드 할 때 문제가 발생하기도 한다.
// - 바이너리 형태로만 제공되는 라이브러리를 사용하는 상태에서 현재 사용하는 컴파일러를 새 버전으로 업그레이드 하면
//   문제가 발생할 수 있다.


// [3] 판단 기준 정리
// 코드 재사용 여부는 주어진 상황과 목적에 따라 판단해야 한다. 흔히 직접 작성하는데 걸리는 시간과 주어진 문제에
// 적절한 라이브러리를 찾아서 사용법을 익히는데 걸리는 시간을 잘 비교해서 결정해야 하는 경우가 많다.

// 마지막으로 명심할 점은 언제든지 결정을 뒤집어도 된다는 것이다. 프로그램을 제대로 추상화했다면 결정을 바꾸더라도
// 큰 부담 없이 대응할 수 있다.



int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.5.3 코드 재사용 전략
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;


// 공통적으로 고려할 사항이 몇 가지 있다.

// [1] 기능과 제약사항 파악하기
// 사용할 코드를 충분히 분석한다. 이때 코드의 기능뿐만 아니라 제약사항도 파악한다.
// 라이브러리를 선정할 때 명심할 사항을 몇 가지 제시하면 다음과 같다.
// - 멀티스레드 프로그램에서 사용해도 안전한지 파악한다.
// - 라이브러리를 사용하는 코드에 대해 특별히 컴파일러에 설정해야 할 사항이 있는지, 만약 그렇다면 프로젝트 전체에
//   적용해도 문제가 없는지 확인한다.
// - 사용할 라이브러리나 프레임워크에서 의존하는 라이브러리가 있는지 확인한다.

// 또한 라이브러리에 따라 다음과 같이 좀 더 구체적인 특성을 확인해야 한다.
// - 초기화나 종료 시 반드시 수행할 작업이 있는지 확인한다.
// - 클래스를 상속할 때 어떤 생성자를 호출해야 하고, 어떤 가상 메서드를 오버라이드해야 하는지 파악한다.
// - 함수가 메모리 포인터를 리턴할 때 그 메모리를 해제하는 작업을 호출한 코드와 라이브러리 중에서 어느 쪽이
//   책임져야 하는지 파악한다.
// - 함수에서 리턴하는 값이나 레퍼런스를 모두 파악한다.
// - 함수에서 던지는 익셉션을 모두 파악한다.
// - 라이브러리를 호출할 때 어떤 에러 조건을 확인해야 하는지, 이때 어떤 상황을 가정하는지 파악한다.


// [2] 학습 비용 파악하기
// 학습 비용은 사용하려는 라이브러리를 익히는 데 걸리는 시간을 말한다.
// 널리 알려진 라이브러리에 원하는 기능이 있다면 처음 보는 라이브러리를 사용하기보다는 기존 라이브러리를 활용하는 것이 낫다.


// [3] 성능 파악하기
// 재사용하려는 코드의 성능이 어느 수준까지 보장되는지 파악하는 것도 중요하다.

// 빅오 표기법 - 알고리즘이나 라이브러리의 성능에 대해 얘기할 때 흔히 빅오표기법을 사용한다.
// 너무 길기도 하고 다 아는 얘기니 넘어가겠다.


// [4] 플랫폼 제약사항 파악하기
// 라이브러리 코드를 사용하기 전에 그 코드를 실행할 플랫폼부터 확실히 파악한다.
// 예를 들어 크로스 플랫폼을 지원하는 애플리케이션을 개발한다면 사용하려는 라이브러리도 크로스 플랫폼을 지원해야 한다.
// 여기서 플랫폼이란 OS의 종류뿐만 아니라 같은 OS라도 버전마다 구분한다. ex) 솔라리스8, 솔라리스9


// [5] 라이선스와 기술 지원 파악하기
// 서드파티 라이브러리를 사용하면 복잡한 라이선스 문제가 발생하기 쉽다. 서드파티 라이브러리 벤더에게
// 라이선스 비용을 지불해야 할 수도 있다. 또한 수출 금지와 같은 부가적인 제약사항이 뒤따를 수도 있다.


// [6] 기술 지원 및 도움을 받을 수 있는 곳 파악하기
// 서드파티 라이버르리를 사용할 때는 기술 지원 문제도 검토해야 한다.
// 라이브러리를 사용하기 전에 버그 리포트 절차나 버그 수정이 완료될 때까지 걸리는 기간 등도 반드시 파악한다.


// [7] 프로토타입
// 라이브러리나 프레임워크를 처음 사용할 때 간단히 프로토타입을 구현해보면 도움이 된다.
// 라이브러리에서 제공하는 기능을 익히는 가장 좋은 방법은 직접 코드를 작성해보는 것이다.
// 이 과정에서 만든 프로토타입이 최종 결과물과 거리가 멀더라도 결코 시간 낭비가 아니다.
// 프로토타입을 만드는 이유는 어디까지나 라이브러리 기능을 파악하는 데 있다.


// [8] 오픈소스 라이브러리
// 오픈소스란 일반적으로 누구나 코드를 들여다 볼 수 있다는 것을 의미한다.
// 오픈소스 소프트웨어에서 가장 중요한 부분은 누구나 소스 코드를 볼 수 있어야 한다는 점이다.
// 여기서 주의할 점은 오픈소스는 단순히 라이브러리에만 적용되지 않는다. ex) 안드로이드 OS, 리눅스 OS

// 오픈소스 라이브러리는 대부분 웹에서 제공한다.
// 인터넷에서 '오픈소스 C++라이브러리 XML 파싱'으로 검색하면 C와 C++로 구현된 XML 라이브러리들을 볼 수 있다.
// 또한 다음과 같은 오픈소스 포탈을 이용하면 오픈소스 소프트웨어를 좀 더 쉽게 검색할 수 있다.
// - www.boost.org
// - www.gnu.org
// - github.com/open-source
// - www.sourceforge.net

// 오픈소스 코드 활용 방법
// 오픈소스 라이브러리를 활용할 때 고려해야할 사항은 오픈소스 특성상 공동으로 개발하고 책임지는 사람도 따로 없기 때문에
// 기술 지원에 관련된 문제가 자주 발생한다는 것이다.
// 당장 수정해야할 버그가 있다면 오픈소스 커뮤니티에서 누군가 수정해주길 기다리는 것보다 본인이 직접 수정하는 것이 빠를 때가 많다.



// [9] C++ 표준 라이브러리
// C++ 프로그래머에게 가장 중요한 라이브러리는 C++ 표준 라이브러리다. 표준이란 명칭에서 예상할 수 있듯이
// C++ 표준의 일부다. 표준 라이브러리는 한 덩어리가 아니라 여러 개의 독립적인 컴포넌트로 구성 되어 있다.

// C 표준 라이브러리
// C++는 C의 기능을 대부분 포함하고 있다. 따라서 C 표준 라이브러리도 그대로 사용할 수 있다.

// 표준 라이브러리의 사용 여부 판단 기준
// 표준 라이브러리는 기능과 성능, 직교성 위주로 설계되었다. 따라서 이를 활용함으로써 얻을 수 있는 효과는 상당하다.
// 또한 C++ 개발자는 대부분 표준 라이브러리에서 제공하는 기능을 활용할 줄 안다. 그러므로 표준 라이브러리로 개발한 프로젝트는
// 새로운 멤버가 들어와도 학습에 걸리는 시간이 서드파티 라이브러리를 사용할 때보다 훨씬 적다.
// 표준 라이브러리에서 제공하는 기능은 나중에 자세히 설명한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.6 체스 프로그램 설계
// 4.6.1 요구사항
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이 절에서는 간단한 체스 게임 예제를 통해 C++ 프로그램을 체계적으로 설계하는 방법을 소개한다.



// 본격적인 설계 작업에 들어가기 전에 만들려는 프로그램의 기능과 성능에 대한 요구사항을 명확히 정리해야 한다.
// 이러한 요구사항은 요구사항 명세서라는 문서 형태로 정리하는 것이 가장 바람직하다.
// 이 절에서 살펴볼 체스 프로그램의 요구사항은 대략 다음과 같다. 물론 실전에서는 이보다 구체적이고 다양하게 작성해야 한다.
// - 표준 체스 규칙을 준수한다.
// - 두 명의 플레이어를 지원해야 한다. 컴퓨터가 조작하는 플레이어는 제공하지 않는다.
// - 인터페이스는 텍스트 기반으로 제공한다.
//   - 체스보드와 말은 일반 텍스트로 표현한다.
//   - 플레이어는 체스보드의 위치를 숫자로 입력하는 방식으로 말을 움직인다.
// 이렇게 요구사항을 정의해두면 사용자가 원하는 방식으로 작동하도록 프로그램을 설계할 수 잇다.


int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.6 체스 프로그램 설계
// 4.6.2 설계 단계
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이 절에서는 간단한 체스 게임 예제를 통해 C++ 프로그램을 체계적으로 설계하는 방법을 소개한다.



// 프로그램을 설계할 때는 일반적인 부분에서 시작해서 점차 구체적인 부분으로 진행한다.
// 이 절에서 소개하는 단계가 모든 프로그램에 들어맞지 않을 수 있지만 개략적인 방법을 파악하는데는 충분하다.
// 필요하다면 다이어그램과 표도 작성한다. 이러한 다이어그램에 대한 산업 표준으로 UML이란 것도 있다.


// [1] 프로그램을 서브시스템으로 분할하기
// 먼저 프로그램을 기능에 따라 서브시스템 단위로 분할하고 각각에 대한 인터페이스와 연동 방식을 정의한다.
// 이때 데이터 구조나 알고리즘, 심지어 클래스에 대해서는 신경쓰지 않는다.
// 프로그램의 전반적인 구성과 각 요소의 연동 방식을 구상하는 데만 집중한다.

// 여기서 살펴볼 체스 프로그램을 설계할 때는 모델-뷰-컨트롤러(MVC) 패러다임을 적용해서 데이터를 저장하는
// 데이터를 화면에 표시하는 부분을 확실히 구분하면 좋다.
// MVC에서는 데이터 집합을 모델, 이 모델을 특정한 방식에 따라 시각적으로 표현하는 것을 뷰, 발생하는 이벤트에 따라
// 이러한 모델을 조작하는 코드를 컨트롤러라 부른다. MVC를 구성하는 이러한 세가지 요소는
// 피드백 루프를 기반으로 연동된다.
// 이 패러다임에 따라 설계하면 다양한 컴포넌트를 명확히 구분할 수 있고, 각각을 다른 것에 영향을
// 미치지 않고 독립적으로 수정할 수도 있다. 예를 들어 내부 데이터 모델이나 로직을 건드리지 않고도
// 텍스트 기반 인터페이스와 그래픽 기반 인터페이스를 서로 맞바꾸거나, 데스크톱 PC용 인터페이스와 모바일 앱 인터페이스를 맞바꿀 수 있다.

//         ----- 화면에 표시한다 --- |    뷰    |<--- 갱신한다 ----
//        |                              |                      |
//		사용자                        조작한다                  모델
//		  |                              |                      |
//         ----- 사용한다 --------->| 컨트롤러 | ----- 조작한다 ---
//

// 체스 프로그램을 구성하는 서브시스템을 표로 정리하면 다음과 같다. - 너무 길어서 생략한다.

// 체스 프로그램은 기능에 따라 GamePlay, ChessBoard, ChessBoardView, ChessPiece 32개, ChessPieceView
// , Player 2개, ErrorLogger 등으로 구성된다. 반드시 이렇게 구성할 필요는 없다.

// 서브시스템으로 잘 구성하면 프로그램을 기본 기능에 따라 분리할 수 있다. 예를 들어 Player는 ChessBoard나 ChessPiece, GamePlay와는
// 구분되는 하나의 서브시스템이다. Player를 GamePlay 서브시스템과 합치면 서로 논리적으로 구분되지 않아서 바람직하지 않다.

// 이렇게 MVC 패턴을 적용하면 ChessBoard와 ChessPiece 서브시스템은 모델에 속한다.
// ChessBoardView와 ChessPieceView는 뷰에 속하고, Player는 컨트롤러에 해당한다.

// 체스 게임의 서브시스템 관계를 UML로 표현하면 다음과 같다.
//       ----------------------->| Player |------ Move/CheckMove---------------------
//      |                            |                                              |
//   TakeTurn                     GetPieceAt                                        |
//		|                            |                                              |
//  GamePlay | <----GameDver-----| ChessBoard | <--- GetPieceAt/ SetPieceAt --| ChessPiece |
//      |
//     Draw
//      |
//       ---->| ChessBoardView | - Draw --> | ChessPieceView |


// [2] 스레드 모델 선택하기
// 루프에 스레드를 적용하는 방식처럼 알고리즘 구현 단계에서 고려해야 할 사항을 설계 단계부터 고민할 필요는 없다.
// 하지만 프로그램에서 사용할 최상위 스레드 수와 각각의 상호 작용 방식 정도는 정해두는 것이 좋다.
// 이러한 최상위 스레드에 대한 예로 UI스레드, 오디오 재생 스레드, 네트워크 통신 스레드 등이 있다.

// 멀티스레드 기반으로 설계할 때 데이터를 공유하는 부분을 최대한 피하는 것이 간결성과 안전성 측면에서 좋다.
// 굳이 공유해야 한다면 잠금(락) 방식을 정한다.

// 이 절에서 살펴보는 체스 프로그램은 게임 흐름을 제어하는데 스레드 하나면 충분하다.

// [3] 서브시스템의 클래스 계층 구성하기
// 이 단계에서는 프로그램에 구현할 클래스 계층을 결정한다.

//						  ChessPiece
//							   |
//    --------------------------------------------------
// 	  |          |        |         |         |        |
//   Rook     Bishop    Knight     King     Pawn     Queen
// 여기서 제네릭 ChessPiece 클래스는 추상 베이스 클래스 역할을 한다.

// ChessBoardView 클래스에는 다른 클래스 계층을 사용하여 텍스트 기반 인터페이스 또는 그래픽 기반 인터페이스를 게임에 사용할 수 있다.
//							
//									ChessBoardView
//										   |
//     --------------------------------------------------------------------------
//     |                                   |                                     |
//  ChessBoardViewConsole              ChessBoardViewGUI2D					ChessBoardViewGUI3D


// [4] 서브시스템의 클래스, 데이터 구조, 알고리즘, 패턴 지정하기
// 좀 더 세부적으로 들어가서 각 서브시스템에 구현할 구체적인 클래스와 같이 서브시스템에 대한 세부사항을 지정한다.
// 서브시스템을 곧바로 클래스로 표현할 가능성도 있다. 이러한 결정사항도 다음과 같이 표로 정리할 수 있다. - 이 부분도 생략

// 소프트웨어 설계에 담긴 다양한 클래스에 대한 정보를 간략히 정리했지만 각 클래스의 상호 작용을 담고 있진 않다.
// 이런 상호 작용은 UML 시퀀스 다이어그램으로 표현한다. - 같은 이유로 생략

// 클래스를 정의하고 데이터 구조와 알고리즘과 패턴을 적용하는 과정은 간단하지 않다.
// 이때 앞에서 설명한 추상화와 재사용성의 원칙을 최대한 적용한다. 추상화의 핵심은 인터페이스와 구현을 따로 구분하는 데 있다.


// [5] 서브시스템의 에러 처리 방법 정하기
// 이 단계에서는 각 서브시스템에 적용할 에러 처리 방법을 나열한다.
// 서브시스템에서 익셉션을 사용하는지도 지정한다. 이러한 정보도 마찬가지로 다음과 같이 표로 정리한다. - 생략

// 에러 처리의 기본 원칙은 모든 에러를 처리하는 것이다. 따라서 발생 가능한 경우의 수를 면밀히 검토한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.7 정리
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 이 장에서는 C++ 프로그램을 전문가답게 설계하는 방법을 배웠다
// 이제 어떤 프로젝트를 진행하더라도 가장 먼저 소프트웨어 설계 작업부터 해야 한다고 깨달았을 것이다.

// 이 장에서는 두 가지 설계 개념을 소개했다.
// 하나는 인터페이스와 구현을 분리하는 추상화 원칙이다.
// 이 원칙은 설계할 때 반드시 적용해야 하며, 이 책에 나온 예제도 모두 이 원칙에 따라 작성했다.

// 두번째 원칙은 재사용이다. 재사용 원칙은 코드 작성 단계뿐만 아니라 설계 단계에도 적용되며,
// 실전 프로젝트에서 흔히 고려하는 사항이다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.8
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 연습 문제 4-1
// 추상화, 재사용

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.8
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 연습 문제 4-2


class Card
{
public:
	enum class Number { Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King };
	enum class Figure { Diamond, Heart, Spade, Club };

	Card() {};
	Card(Number number, Figure figure)
		: m_number{ number }, m_figure{ figure } {}
private:
	Number m_number{ Number::Ace };
	Figure m_figure{ Figure::Diamond };
};

//// The problem with the following representation for a deck of cards is that it
//// is impossible to guarantee certain invariants. For example, an initial deck of
//// cards has exactly 52 cards, all different from each other. With a simple array,
//// everyone can just manipulate the array of cards, adding duplicate cards, and so on.

//int main()
//{
//	Card deck[52];
//}



//// A better approach is to wrap a deck of cards in a class, which enforces any
//// invariants, and which can include additional functionality such as shuffling a deck.

import <vector>;

class Deck
{
public:
	Deck() { /* Initialize a valid deck of cards... */ }

	// Retrieves the card with given index.
	// Throws std::out_of_range if index is an invalid index.
	const Card& getCard(size_t index) const { /* Validate index and return the card with given index... */ }

	// Shuffles the deck of cards.
	void shuffle() { /* Shuffle the deck... */ }

	// More methods ...

private:
	std::vector<Card> m_deck;
};

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.8
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 연습 문제 4-3
// 안드로이드OS 와 IOS에 종속되지 않는 코드는 유지하도록 설계하고
// 종속되는 부분만 수정한다.

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.8
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 연습 문제 4-4
// O(1) -> O(logn) -> O(n) -> O(n^2)

int main()
{
	

	save("helloworld.cpp");
}

================================================



================================================
﻿// helloworld.cpp

/////////////////////////////////////////////////////////////////
// 2023.07.08 공부
// Chapter4 전문가답게 C++ 프로그램 설게하기
// 4.8
/////////////////////////////////////////////////////////////////

#include <iostream>


//import database;
//import employee;

//import airline_ticket;

#include "save.h"

using namespace std;

// 연습 문제 4-4
// O(1) -> O(logn) -> O(n) -> O(n^2)

int main()
{
	

	save("helloworld.cpp");
}

// Chapter4 전문가답게 C++ 프로그램 설게하기 完================================================
