


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 5 프로토타입
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서
// 새로운 객체를 생성합니다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 5 프로토타입
// 5.1 프로토타입 디자인 패턴
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// <건틀릿> 같은 게임을 만든다고 해보자.
// 몬스터들은 영웅을 잡아먹기 위해 떼지어 다닌다.
// 영웅은 저녁 식사 삼으려는 이 음침한 녀석들은 '스포너'를 통해 게임 레벨에 등장하는데, 몬스터 종류마다 스포너가 따로 있다.
/*
class Monster {
	// 기타 등등...
};
class Ghost : public Monster{};
class Demon : public Monster{};
class Sorcerer : public Monster{};

// 한가지 스포너는 한 가지 몬스터 인스턴스만 만든다.
// 게임에 나오는 모든 몬스터들 지원하기 위해 일단 마구잡이로 몬스터 클래스마다 스포너 클래스를 만든다고 치자.
// =====================================================================================
//          - Ghost									- Ghost_Spawner
//  Monster - Demon                        Spawner  - Demon_Spawner
//			- Sorcerer								- Sorcerer_Spawner

class Spawner {
public:
	virtual ~Spawner(){}
	virtual Monster* spawnMonster() = 0;

};

class GhostSpawner : public Spawner {
public:
	virtual Monster* spawnMonster() {
		return new Ghost();
	}
};

class DemonSpawner : public Spawner {
public:
	virtual Monster* spawnMonster(){
		return new Demon();
	}
};
// 뭘 하려는 건지 알 것이다...

// 코드를 많이 작성할수록 돈을 더 받는다면 모를까. 이 코드는 영 별로다. 클래스도 많지, 행사코드도 많지,
// 반복 코드도 많지, 중복도 많지..
// 이런 걸 프로토타입 패턴으로 해결할 수 있다.
// 핵심은 어떤 객체가 자기와 비슷한 객체를 스폰할 수 있다는 점이다. 유령 객체 하나로 다른 유령 객체를 여럿 만들 수 있다.
// 어떤 몬스터 객체든지 자신과 비슷한 몬스터 객체를 만드는 원형 객체로 사용할 수 있다.

// 이를 구현하기 위해, 상위 클래스인 Monster에 추상 메서드 clone()을 추가한다.
class Monster {
public:
	virtual ~Monster() {}
	virtual Monster* clone() = 0;

	// 그 외...
};

// Monster 하위 클래스에서는 자신과 자료형과 상태가 같은 새로운 객체를 반환하도록 clone()을 구현한다.

class Class : public Monster {
public:
	Ghost(int health, int speed) : health_(health), speed_(speed) {}

	virtual Monster* clone() {
		return new Ghost(health_, speed_);
	}
private:
	int health_;
	int speed_;
};

// Monster를 상속받는 모든 클래스에 clone 메서드가 있다면, 스포너 클래스를 종류별로 만들 필요 없이 하나만 만들면 된다.
class Spawner {
public:
	Spawner(Monster* prototype) : prototype_(prototype) {}
	Monster* spawnMonster() {
		return prototype_->clone();
	}
private:
	Monster* prototype_;
};

// Spawner 클래스 내부에는 Monster 객체가 숨어 있다. 이 객체는 벌집을 떠나지 않는 여왕벌처럼
// 자기와 같은 Monster 객체를 도장 찍듯 만들어내는 스포너 역할만 한다.
// =========================================================================
// 스포너
// 몬스터----------------------------------clone()---------->  몬스터
//  |--- 프로토타입											   몬스터

// 유령 스포너를 만들려면 원형으로 사용할 유령 인스턴스를 만든 후에 스포너에 전달한다.
Monster* ghostPrototype = new Ghost(15, 3);
Spawner* ghostSpawner = new Spawner(ghostPrototype);
// 프로토타입 패턴의 좋은 점은 프로토타입의 클래스뿐만 아니라 상태도 같이 복제한다는 점이다.
// 즉 원형으로 사용할 유령 객체를 잘 설정하면 빠른 유령, 약한 유령, 느린 유령용 스포너 같은 것도 싶게 만들 수 있다.
// 프로토타입 패턴은 우아하면서도 놀랍다. 또한 너무 간단하기 때문에 따로 외우려 노력하지 않아도 까먹을 수가 없다.


// 얼마나 잘 작동하는가?
// 이제 몬스터마다 스포너 클래스를 따로 만들지 않아도 된다. 그래도 Monster 클래스마다 clone()을 구현해야 하기 때문에
// 코드 양은 별반 차이가 없다.

// 프로토타입 패턴을 써도 코드양이 많이 줄어들지 않는데다가, 예제부터가 현실적이지 않다.
// 요즘 나오는 웬만한 게임 엔진에서는 몬스터마다 클래스를 따로 만들지 않는다.

// 우리 프로그래머들은 오랜 삽질을 통해서 클래스 상속 구조가 복잡하면 유지보수하기 힘들다는 걸 체득했기 때문에,
// 요즘은 개체 종류별로 클래스를 만들기보다는 컴포넌트나 타입 객체로 모델링하는 것을 선호한다.


// 스폰 함수
// 앞에서는 모든 몬스터마다 별도의 스포너 클래스가 필요했다. 하지만 모든 일에는 답이 여러개 있는 법이다.
Monster* spawnGhost() {
	return new Ghost();
}

// 몬스터 종류마다 클래스를 만드는 것보다는 행사코드가 훨씬 적다. 이제 스포너 클래스에는 함수 포인터 하나만 두면 된다.
typedef Monster* (*SpawnCallback());

class Spawner {
public:
	Spawner(SpawnCallback spawn) : spawn_(spawn){}
	Monster* spawnMonster() { return spawn_(); }

private:
	SpawnCallback spawn_;
};
// 유령을 스폰하는 객체는 이렇게 만들 수 있다.
// Spawner* ghostSpawner = new Spawner(spawnGhost);


// 템플릿
// 요즘 C++ 프로그래머는 다들 템플릿을 잘 안다. 스포너 클래스를 이용해 인스턴스를 생성하고 싶지만
// 특정 몬스터 클래스를 하드코딩하기는 싫다면 몬스터 클래스를 템플릿 타입 매개변수로 전달하면 된다.
class Spawner {
public:
	virtual ~Spawner() {}
	virtual Monster* spawnMonster() = 0;
};

template <class T>
class SpawnerFor : public Spawner {
public:
	virtual Monster* spawnMonster() { return new T(); }
};

// 템플릿으로 만들면 사용법은 다음과 같다.
Spawner* ghostSpawner = new SpawnerFor<Ghost>();


// 일급 자료형
// 앞에서 본 두 방법을 통해서 Spawner 클래스에 자료형을 매개변수로 전달할 수 있다.
// C++에서는 자료형이 일급 자료형이 아니다 보니 이런 곡예를 해야 한다.
// 자바스크립트, 파이썬, 루비등 클래스가 전달 가능한 일급 자료형인 동적 자료형 언어에서는 이 문제를 훨씬 직접적으로 풀 수 있다.

*/

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 5 프로토타입
// 5.2 프로토타입 언어 패러다임
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// '객체지향 프로그래밍'이 곧 '클래스'라고 많이들 생각한다.
// 갈라진 여러 종교 종파처럼 사람들은 OOP를 다르게 정의하지만,
// OOP가 데이터와 코드를 묶어주는 '객체'를 직접 정의할 수 있게 한다는 점만큼은 대부분 동의한다.
// OOP의 가장 큰 특징은 상태와 동작을 함께 묶는 데 있다.

// 클래스만이 이를 위한 유일한 방법일 거라고 생각할지 모르나, 셀프라는 언어를 만들었다.
// 셀프에서는 OOP에서 할 수 있다는 걸 다 할 수 있지만 클래스는 없다.


// 셀프
// 순수하게 의미만 놓고 보면 셀프는 클래스 기반 언어보다 더 객체지향적이다.
// 객체 상태를 알기 위해서는 해당 인스턴스의 메모리를 들여다봐야 한다. - 클래스 기반언어
// 즉, 상태는 인스턴스에 들어있다.
// 반대로 메서드를 호출할 때는 인스턴스의 클래스를 찾는다. 즉, 동작은 클래스에 있다. 항상 한 단계를 거쳐서
// 메서드를 호출한다는 점에서 필드(상태)와 메서드는 다르다.

// =======================================================
// 클래스  ----------------------------> 인스턴스
// 메서드								 필드
// 메서드								 필드
// 메서드								 필드
// ...

// 셀프에는 이런 구별이 없다. 무엇이든 객체에서 바로 찾을 수 있다.
// 인스턴스는 상태와 동작 둘 다 가질 수 있다. 유일무이한 메서드를 가진 객체도 만들 수 있다.
// ==============================================================
// 객체
// ------
// 필드
// 메서드
// 필드

// 상속은 코드를 재사용하고 중복코드를 줄일 수 있다는 장점이 있다.
// 클래스 없이 이러한 일을 수행하기 위해 셀프에는 위임(delegation) 개념이 있다.
// 해당 객체에서 필드나 메서드를 찾아본다. 있다면 그걸 쓰고, 없다면 상위 객체를 찾아본다.
// 상위 객체는 그냥 다른 객체 레퍼런스일 뿐이다. 첫 번째 객체에 속성이 없다면 상위 객체를 살펴보고
// 그대로 없다면 상위의 상위객체에서 찾아보고 이를 반복한다. 다시 말해 찾아보고 없으면 상위객체에 윙미한다.
// ===============================================================
// 객체  ------------------------------------------- > 객체
// 필드												   부모
// 메서드                                              필드
// 필드                                                메서드
// ...                                                 ...
// 상위 객체를 통해서 동작(과 상태!)을 여러 객체가 재사용할 수 있기 때문에 클래스가 제공하는 기능 대부분을 대신할 수 있다.


// 클래스의 또 다른 역할은 인스턴스 생성이다.
// 클래스가 없다면 어떤 식으로 객체를 만들수 있는가?
// 셀프에서는 프로토타입 패턴에서 본 것처럼 복제하면 된다.
// 셀프에서는 모든 객체가 프로토타입 디자인 패턴을 저절로 지원하는 것과 다를 게 없다.
// 모든 객체가 복제될 수 있기 때문에 비슷한 객체를 여럿 만들려면 다음과 같이 한다.
// 1. 객체 하나를 원하는 상태로 만든다. 시스템에서 제공하는 기본 Object 객체를 복제한 뒤에 필드와 메서드를 채워 넣는다.
// 2. 원하는 만큼 복제한다.
// 셀프에서는 귀찮게 직접 clone 메서드를 구현하지 않아도 프로토타입 디자인 패턴의 우아함을 시스템적으로 제공한다.

// 사용하다 보니 슬픈 소식을 알게 되었는데 프로토타입기반으로 프로그래밍하는 게 별로 재미없다는 슬픈 사실을 알게 되었다.
// 분명 언어를 구현하기는 쉬웠지만, 그게 다 복잡한 걸 사용자에게 떠넘겼기 때문이다.
// 프로토타입은 널리 알리고 싶을 정도로 끝내주는 개념이지만, 한편으로는 프로토타입 방식으로
// 매일 프로그래밍하지 않아도 된다는 사실이 고맙기도 한다. 온전히 프로토타입 방식만으로 구현한 코드는
// 두루뭉술해서 나로서는 이해하기가 너무 어려웠다.

// 수많은 사람들이 매일 사용하는 자바스크립트 언어는 프로토타입 기반으로 만들어졌는데
// 왜 프로토타입 기반 언어가 접근성이 낮다고 하는것인가? 그것은 자바스크립트가 프로토타입 기반 언어보다
// 클래스 기반 언어에 더 가깝기 때문이라고 생각한다.

// - 자바스크립트에서는 자료형을 정의하는 객체로부터 new를 호출하는 생성자 함수를 통해 객체를 생성한다.
// - 상태는 인스턴스 그 자체에 저장된다.
// - 동작은 자료형이 같은 객체 모두가 공유하는 메서드 집합을 대표하는 별도 객체인 프로토타입에 저장되고 위임을 통해 간접 접근된다.



int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 5 프로토타입
// 5.3 데이터 모델링을 위한 프로토타입
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 프로토타입이, 더 정확하게는 위임 개념이 쓸모 있는 분야를 알아보면서 이번 장을 마무리해보자.
// 세월이 지날수록 게임 바이너리에서 코드보다 데이터가 차지하는 용량이 커지고 있다.
// 요즘 게임에서 코드는 게임을 실행하기 위한 '엔진'일 뿐, 게임 콘텐츠는
// 모두 데이터에 정의되어 있다. 여기까진 좋다.
// 하지만 많은 콘텐츠를 데이터로 옮기면 대규모 프로젝트의 구조 문제가 오히려 어려워진다면 모를까
// 저절로 해결되지는 않는다. 프로그래밍 언어를 사용하는 이유는 복잡성을 제어할 수 있는 수단을 가지고 있어서이다.

// 게임 데이터도 규모가 일정 이상이 되면 코드와 비슷한 기능이 필요하다.
// 프로토타입과 위임을 활용해 데이터를 재사용하는 기법을 하나 소개하겠다.

// 앞에서 얘기한 <건틀릿> 카피 게임용 데이터 모델을 정희한다고 해보자. 
// 기획자는 몬스터와 아이템 속성을 파일 어딘가에 정의해야 한다.
// 이럴 때 많이 사용하는 방법중 하나가 JSON이다. 워낙 프로그래머들이 이미 있는 개념에 새로운 이름을 붙이길 좋아하다 보니
// 키/값 구조로 이루어진 데이터 개체는 맵, 또는 속성 목록등 그 외 여러 용어로 불리고 있다.
// 고블린은 이런 식으로 정의될 것이다.
/*
{
	"이름" :"고블린 보병",
	"기본체력": 20,
	"최대체력": 30,
	"내성":["추위","독"] ,
	"약점":["불","빛"] ,
}

{
	"이름" :"고블린 마법사",
		"기본체력" : 20,
		"최대체력" : 30,
		"내성" : ["추위", "독"] ,
		"약점" : ["불", "빛"] ,
		"마법" : ["화염구", "번개화살"] ,
}

// 개체에 중복이 많다. 이게 진짜 코드였다면 바로 눈에 거슬렸을 것이다.
// 좋은 프로그래머는 중복을 싫어한다. 중복은 공간을 낭비하고 제작 시간을 늘린다.
// 조금 더 영리하게 해보자.
{
	"이름" :"고블린 보병",
		"기본체력" : 20,
		"최대체력" : 30,
		"내성" : ["추위", "독"] ,
		"약점" : ["불", "빛"] ,
}

{
	"이름" :"고블린 마법사",
		"프로토 타입" : "고블린 보병",
		"마법" : ["화염구", "번개화살"] ,
}
// 마법사에서 보병을 프로토타입으로 지정했기 때문에
// 체력, 내성, 약점을 반복 입력하지 않아도 된다. - 데이터 모델에 단순한 위임을 하나 추가했을 뿐인데 중복을 많이 제거할 수 있었다.


// 보스와 유니크 아이템은 일반 아이템을 약간 다듬어 만들 때가 많으므로 프로토타입 방식의 위임을 써먹기 좋다.
// '참수의 마법검'처럼 일반 롱소드에 보너스가 살짝 붙은 마법 아이템 데이터는 이런 식으로 표현 할 수 있다.
{
	"이름" : "참수의 마법검",
	"프로토 타입" : "롱소드",
	"보너스대미지" : "20"
}

// 데이터 모델링 시스템에 기능을 약간 추가했을 뿐이지만, 기획자는 기존 무기나 몬스터를 약간 변형해
// 쉽게 게임 월드를 풍성하게 만들 수 있게 되었다. 이런 풍성함이야말로 유저가 원하는 것이다.
*/
int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================
