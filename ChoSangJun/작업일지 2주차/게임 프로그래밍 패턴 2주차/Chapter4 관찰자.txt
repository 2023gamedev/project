


================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"

// 객체 사이에 일대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에
// 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만듭니다.

// 모델-뷰-컨트롤러(MVC) 구조를 쓰는 프로그램이 발에 차일 정도로 MVC 패턴을 많이 사용하는데,
// 그 기반에는 관찰자 패턴이 있다.
// 하도 많이 쓰여서 java에서는 핵심 라이브러리로 들어가 있고 C#에서는 event 키워드로 지원한다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.1 업정 달성
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"

// 업적 시스템을 추가한다고 해보자. '괴물 원숭이 100마리 잡기' 등의 특정 기준을 완료하면
// 배지를 주는데 종류가 수백개가 넘는다고 하자.
// 업적 종류가 광범위하고 달성할 수 있는 방법도 다양하다 보니 깔끔하게 구현하기가 어렵다.

// 이럴 때 관찰자 패턴을 쓰면 된다. 관찰자 패턴을 적용하면 어떤 코드에서 흥미로운 일이 생겼을 때
// 누가 받든 상관없이 알림을 보낼 수 있다.

/*
void Physics::updateEntity(Entity& entity) {
	bool wasOnSurface = entity.isOnSurface();
	entity.acclerate(GRAVITY);
	entity.update();
	if (wasOnSurface && !entity.isOnSurface()) {
		notify(entity, EVENT_START_FALL);
	}
}
*/
// 이 코드는 '이게 방금 떨어지기 시작했으니 누군지는 몰라도 알아서 하시오'라고 알려주는게 전부다.
// 업적 시스템은 물리 엔진이 알림을 보낼 때마다 받을 수 있도록 스스로를 등록한다.
// 업적 시스템은 떨어지는 물체가 불쌍한 우리 캐릭터가 맞는지, 그리고 떨어지기 전에 다리 위에 있었는지를
// 확인한 뒤에 축포와 함꼐 업적을 잠금해제한다. 이런 과정을 물리 코드는 전혀 몰라도 된다.
// 이렇게 물리 엔진 코드는 전혀 건드리지 않은 채로 업적 목록을 바꾸거나 아예 업적 시스템을 떼어낼 수도 있다.
// 물리 코드는 누가 받든 말든 계속 알림을 보낸다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.1 업정 달성
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"

// 업적 시스템을 추가한다고 해보자. '괴물 원숭이 100마리 잡기' 등의 특정 기준을 완료하면
// 배지를 주는데 종류가 수백개가 넘는다고 하자.
// 업적 종류가 광범위하고 달성할 수 있는 방법도 다양하다 보니 깔끔하게 구현하기가 어렵다.

// 이럴 때 관찰자 패턴을 쓰면 된다. 관찰자 패턴을 적용하면 어떤 코드에서 흥미로운 일이 생겼을 때
// 누가 받든 상관없이 알림을 보낼 수 있다.

/*
void Physics::updateEntity(Entity& entity) {
	bool wasOnSurface = entity.isOnSurface();
	entity.acclerate(GRAVITY);
	entity.update();
	if (wasOnSurface && !entity.isOnSurface()) {
		notify(entity, EVENT_START_FALL);
	}
}
*/
// 이 코드는 '이게 방금 떨어지기 시작했으니 누군지는 몰라도 알아서 하시오'라고 알려주는게 전부다.
// 업적 시스템은 물리 엔진이 알림을 보낼 때마다 받을 수 있도록 스스로를 등록한다.
// 업적 시스템은 떨어지는 물체가 불쌍한 우리 캐릭터가 맞는지, 그리고 떨어지기 전에 다리 위에 있었는지를
// 확인한 뒤에 축포와 함께 업적을 잠금해제한다. 이런 과정을 물리 코드는 전혀 몰라도 된다.
// 이렇게 물리 엔진 코드는 전혀 건드리지 않은 채로 업적 목록을 바꾸거나 아예 업적 시스템을 떼어낼 수도 있다.
// 물리 코드는 누가 받든 말든 계속 알림을 보낸다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.2 작동 원리
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 관찰자
// Observer 클래스
/*
class Observer {
public:
	virtual ~Observer();
	virtual void onNotify(const Entity& entity, Event event) = 0;

};

class Achievement : public Observer {
public:
	virtual void onNotify(const Entity& entity, Event event) {
		switch (event)
		{
		case EVENT_ENTITY_FELL:
			if (entity.isHero() && heroIsOnbridge_) {
				unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
			}
			break;
			// 그 외 다른 이벤트 값을 처리하고...
			// heroIsOnBridge_ 값을 업데이트한다...
		}
	}



private:
	void unlock(Achievement achievement) {
		// 아직 업적이 잠겨 있다면 잠금 해제한다...

	}
	bool heroIsOnBridge_;

};
*/

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.2 작동 원리
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 관찰자
// Observer 클래스
/*
class Observer {
public:
	virtual ~Observer();
	virtual void onNotify(const Entity& entity, Event event) = 0;

};

class Achievement : public Observer {
public:
	virtual void onNotify(const Entity& entity, Event event) {
		switch (event)
		{
		case EVENT_ENTITY_FELL:
			if (entity.isHero() && heroIsOnbridge_) {
				unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
			}
			break;
			// 그 외 다른 이벤트 값을 처리하고...
			// heroIsOnBridge_ 값을 업데이트한다...
		}
	}



private:
	void unlock(Achievement achievement) {
		// 아직 업적이 잠겨 있다면 잠금 해제한다...

	}
	bool heroIsOnBridge_;

};
*/

// 대상
// 알림 메서드는 관찰당하는 객체가 호출된다. 이런 객체를 대상이라고 부른다.
// 대상에게는 두 가지 임무가 있다. 그중 하나는 알림을 끈질기게 기다리는 관찰자 목록을 들고 있는 일이다.
/*
class Subject {
public:
	void addObserver(Observer* observer) {
		// 배열에 추가한다...
	}
	void removeObserver(Observer* observer) {
		// 배열에서 제거한다...
	}
	// 그 외...
private:
	Observer* observers_[MAX_OBSERVERS];
	int numObservers_;
};
*/
// 여기에서 중요한 점은 관찰자 목록을 밖에서 변경할 수 있도록 다음과 같이 API를 puvlic으로 열어놨다는 점이다.

// 이를 통해 누가 알림을 받을 것인지를 제어할 수 있다.
// 대상은 관찰자와 상호작용하지만, 서로 커플링되어 있지 않다.

// 대상이 관찰자를 여러 개 목록으로 관리한다는 점도 중요하다. 자연스럽게 관찰자들은 암시적으로 서로 커플링되지 않는다.
// 오디오 엔진도 뭔가가 떨어질 떄 적당한 소리를 낼 수 있도록 알림을 기다린다고 해보자.
// 대상이 관찰자를 하나만 지원한다면, 오디오 엔진이 자기 자신을 관찰자로 등록할 때 업적 시스템은
// 관찰자 목록에서 제거될 것이다. 즉, 두 시스템이 서로를 방해하는 셈이다.
// 관찰자를 여러 개 등록할 수 있게 하면 관찰자들이 각자 독립적으로 다뤄지는 걸 보장할 수 있다.
// 관찰자는 월드에서 같은 대상을 관찰하는 다른 관찰자가 있는지를 알지 못한다.
// 대상의 다른 임무는 알림을 보내는 것이다.
/*
class Subject {
public:
	void addObserver(Observer* observer) {
		// 배열에 추가한다...
	}
	void removeObserver(Observer* observer) {
		// 배열에서 제거한다...
	}
	// 그 외...

protected:
	void notify( const Entity& entity, Event event){
		for(int i = 0; i < numObservers_; i++){
			observers_[i]->onNotify(entity, event);
			}
	// 그 외...
	};
private:
	Observer* observers_[MAX_OBSERVERS];
	int numObservers_;
};
*/

// 물리 관찰
// 남은 작업은 물리 엔진에 훅을 걸어 알림을 보낼 수 있게 하는 일과 업적 시스템에서 알림을 받을 수 있도록 스스로를 등록하게 하는 일이다.
/*
class Physis : public Subject {
public:
	void updateEntity(Entity& entity);
};
*/

// 이렇게 하면 Subject notify() 메서드를 protected로 만들 수 있다. Subject를 상속받은 Physic 클래스는
// notify()를 통해서 알림을 보낼 수 있지만, 밖에서는 notify()에 접근할 수 없다.
// 반면 addObserver()와 removeObserver()는 public이기 때문에 물리 시스템에 접근할 수 있다면
// 어디서나 물리 시스템을 관찰할 수 있다.
// 이제 물리 엔진에서 뭔가 중요한 일이 생기면, 예제처럼 notify()를 호출해 전체 관찰자에게 알림을 전달하여
// 일을 처리하게 된다.
//-----------------------------------------------------
// 대상
// OBSERVERS_
// [0]			-------------------------> 업적
// [1]			-------------------------> 오디오
//

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.3 "너무 느려"
/////////////////////////////////////////////////////////////////


#include <iostream>

#include "save.h"


// 관찰자 패턴을 제대로 이해하지 못한 프로그래머들이 이런 얘기를 많이 한다.
// 이런 개발자들은 '디자인 패턴' 비슷한 이름만 붙어 있어도 쓸데없이 클래스만 많고 우회나
// 다른 희한한 방법으로 CPU를 낭비할 것이라고 지레짐작한다.

// 관찰자 패턴은 특히 '이벤트', '메시지', 심지어 '데이터 바인딩' 같은 몇몇 어두운 친구들과 어울려 다닌다는
// 얘기 때문에 부당한 평가를 받아왔다. 이런 시스템 중 일부는 알림이 있을 때마다 동적 할당을 하거나 큐잉하기 때문에
// 실제로 느릴 수 있다.

// 하지만 정적 호출보다야 약간 느리긴 하겠지만 진짜 성능에 민감한 코드가 아니라면
// 이 정도 느린 건 문제가 되지 않는다.

// 게다가 관찰자 패턴은 성능에 민감하지 않은 곳에 가장 잘 맞기 때문에, 동적 디스패치를 써도 크게 상관없다.
// 이 점만 제외하면 성능이 나쁠 이유가 없다.


// 주의해야 할 점은 관찰자 패턴이 동기적이라는 점이다.
// 대상이 관찰자 메서드를 직접 호출하기 때문에 모든 관찰자가 알림 메서드를 반환하기 전에는
// 다음 작업을 진행할 수 없다.
// 무시무시하게 들리겠지만 실제로는 그렇게 큰일은 아니다. 그냥 알고 있으면 된다.
// 오랫동안 이벤트 기반 프로그래밍을 해온 UI 프로그래머들은 'UI 스레드를 최대한 멀리하라'는 말은 예전부터 들어왔다.
// 이벤트에 동기적으로 반응한다면 최대한 빨리 작업을 끝나고 제어권을 다시 넘겨줘서 UI가 멈추지 않게 해야 한다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.4 "동적 할당을 너무 많이 해"
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 아무리 관리 언어로 만든다고 해도 게임같이 성능에 민감한 소프트웨어에서는 메모리 할당이 여전히 문제가 된다.
// 저절로 된다고는 하나 메모리를 회수하다 보면 동적 할당이 오래 걸릴 수 있다.

// 물론 실제로는 관찰자가 추가될 때만 메모리를 할당한다. 알림을 보낼 때는 메서드를 호출할 뿐
// 동적 할당은 전혀 하지 않는다. 게임 코드가 실행될 때 처음 관찰자를 등록해놓은 뒤에 건드리지
// 읺는다면 메모리 할당은 거의 일어나지 않는다.

int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.4 "동적 할당을 너무 많이 해"
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 아무리 관리 언어로 만든다고 해도 게임같이 성능에 민감한 소프트웨어에서는 메모리 할당이 여전히 문제가 된다.
// 저절로 된다고는 하나 메모리를 회수하다 보면 동적 할당이 오래 걸릴 수 있다.

// 물론 실제로는 관찰자가 추가될 때만 메모리를 할당한다. 알림을 보낼 때는 메서드를 호출할 뿐
// 동적 할당은 전혀 하지 않는다. 게임 코드가 실행될 때 처음 관찰자를 등록해놓은 뒤에 건드리지
// 읺는다면 메모리 할당은 거의 일어나지 않는다.


// 관찰자 연결 리스트
// ========================================================
// 대상        |------> 관찰자			  |----------> 관찰자
// Head -------         NEXT --------------			   NEXT
// 
// 이를 구현하려면, 먼저 Subject클래스에 배열 대신 관찰자 연결 리스트의 첫째 노드를 가리키는 포인터를 둔다.
/*
class Subject {
	Subject() : head_(NULL) {}

	// 메서드들...
public:
	void addObserver(Observer* observer);
	void removeObserver(Observer* observer);

protected:
	//void notify(const Entity& entity, Event event);
private:
	Observer* head_;
};
// 그리고 Observer에 연결 리스트의 다름 관찰자를 가리키는 포인터를 추가한다.
class Observer {
	friend class Subject;
public:
	Observer() : next_(NULL){}

	// 그 외...

	
private:
	Observer* next_;
};
// 또한 Subject를 friend 클래스로 정의한다.
// Subject에는 관찰자를 추가,삭제하기 위한 API가 있지만 Subject가 관리해야 할 관찰자 목록은 이제 Observer 클래스 안에 있다.
// Subject가 이들 목록에 접근할 수 있게 만드는 가장 간단한 방법은 Observer에서 Subject를 friend클래스로 만드는 것이다.

// 새로운 관찰자를 연결 리스트에 추가하기만 하면 대상에 등록할 수 있다.
// 앞쪽에 추가하는 방식이 간단하므로 그 방식으로 구현하겠다.
void Subject::addObserver(Observer* observer) {
	observer->next_ = head_;
	head_ = observer;
}

// 이 코드의 부작용이 있다면 A B C 순서대로 추가 했다면 C B A순서대로 알림을 받게 된다.

// 등록 취소 코드는 다음과 같다.
void Subject::removeObserver(Observer* observer) {
	if (head_ == observer) {
		head_ = observer->next_;
		observer->next_ = NULL;
		return;
	}

	Observer* current = head_;
	while (current != NULL) {
		if (current->next_ == observer) {
			current->next_ = observer->next_;
			observer->next_ = NULL;
			return;
		}
		current = current->next_;
	}
}
*/

// 이제 알림만 보내면 된다. 단지 목록을 따라가기만 하면 된다.
/*
void Subject::notify(const Entity& entity, Event event) {
	Observer* observer = head_;
	while (observer != NULL) {
		observer->onNotify(entity, event);
		observer = observer->next;
	}
}
*/

// 관찰자 객체 그 자체를 리스트 노드로 활용하기 때문에, 관찰자는 하나의 대상 관찰자 목록에만 등록할 수 있다.
// 다시 말해 관찰자는 한 번에 한 대상만 관찰할 수 있다.

// 한 대상에 여러 관찰자가 붙는 경우가 그 반대보다 훨씬 일반적이다 보니, 이런 한계를 감수하고 갈 수도 있다.


// 리스트 노드 풀
// 전과 마찬가지로 대상이 관찰자 연결 리스트를 들고 있다. 다만, 이 연결 리스트의 노드는 관찰자 객체가 아니다.
// 대신 따로 간단한 '노드'를 만들어, 관찰자와 다음 노드를 포인터로 가리키게 한다.

// ======================================================
// 대상				  |-----> 노드                   |------> 노드
// HEAD_ --------------       NEXT_  -----------------       NEXT_
//                           OBSERVER_---> 관찰자            OBSERVER_---> 관찰자
//
// 같은 관찰자를 여러 노드에서 가리 킬 수 있다는 것은, 같은 관찰자를 동시에 여러 대상에 추가 할 수 있다는 뜻이다.
// 다시 여러 대상을 한 번에 관찰할 수 있게 된다.

// 동적 할당을 피하는 방법은 간단하다. 모든 노드가 같은 자료형에 같은 크기니까 객체 풀에 미리 할당하면 된다.
// 이러면 고정된 크기의 목록 노드를 확보할 수 있어서 필요할 때마다 동적 메모리 할당 없이 재사용할 수 있다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.5 남은 문제점들
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 모든 디자인 패턴과 마찬가지로 관찰자 패턴이 만능은 아니다.
// 기술적인 문제와 유지보수 문제 두 개가 남아 있다. 유지보수보다는 기술적인 문제가 더 쉬운 법이니 이것보자.

// 대상과 관찰자 제거
// 관찰자를 부주의하게 삭제하다 보면 대상에 있는 포인터가 이미 삭제된 객체를 가리킬수 있다.
// 헤제된 메모리를 가리키는 무효 포인터에다가 알림을 보낸다면 그날은 힘든 하루가 될 것이다.

// 보통은 관찰자가 대상을 참조하지 않게 구현하기 때문에 대상을 제거하기가 상대적으로 쉽다.
// 대상이 죽었을 때 관찰자가 계속 기다리는 것을 막는 법은 간단하다. '사망' 알림을 보내주면 된다.

// 관찰자를 제거하는 가장 쉬운 방법은 관찰자가 삭제될 때 스스로를 등록 취소하는 것이다.


// 이쯤 되면 가비지 컬렉터가 있는 최신 언어로 개발하는 독자들은 으쓱하고 있을지 모른다.
// 캐릭터 체력 같은 상태를 보여주는 UI 화면을 생각해보자. 유저가 상태창을 열면 상태창UI 객체를 생성한다.
// 상태창을 닫으면 UI객체를 따로 삭제하지 않고 GC가 알아서 정리하게 한다.

// 유저가 상태창을 닫을 때 관찰자를 등록 취소하지 않으면 어떻게 될까
// UI는 더 이상 보이지 않지만 캐릭터의 관찰자 목록에서 여전히 상태창 UI를 참조하고 있기 때문에
// GC가 수거해 가지 않는다. 상태창을 열때마다 상태창 인스턴스를 새로 만들어 관찰자 목록은 점점 커지게 되버린다.

// 이는 알림 시스템에서 굉장히 자주 일어나는 문제다 보니 사라진 리스터 문제라는 고유한 이름이 붙었을 정도다.
// 이래서 등록 취소는 주의해야 한다.


// 더 어려운 문제는 관찰자 패턴의 원래 목적 때문에 생긴다.(두 코드 간의 결합을 최소화)
// 프로그램이 제대로 동작하지 않을 때 버그가 여러 관찰자에 퍼져 있다면 상호작용 흐름을 추론하기가 훨씬 어렵다.

// 관찰자 패턴은 서로 연관 없는 코드 덩어리들이 하나의 큰 덩어리가 되지 않으면서 서로 상호작용하기에 좋은 방법이지
// 하나의 기능을 구현하기 위한 코드 덩어리 안에서는 그다지 유용하지 않다.
// 그래서 예제에서도 업적과 물리같이 서로 전혀 상관없는 분야를 선택했다. 이런 때엔 각 담당자가 다른 분야를 잘 몰라도
// 작업에 문제가 없도록 상호작용을 최소한으로 유지하는 게 좋다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.6 오늘날의 관찰자
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"

// 최신 방시은 메서드나 함수 레퍼런스만으로 '관찰자'를 만드는 것이다. 일급 함수, 그중에서도
// 클로저를 지원하는 언어에서는 이렇게 관찰자를 만드는게 훨씬 일반적이다.

// 예를 들어 C#에서는 언어 자체에 event가 있어서 메서드를 참조하는 delegate으로 관찰자를 등록할 수 있다.
// 자바스크립트의 이벤트 시스템에서는 EventListener 프로토콜을 지원하는 객체가 관찰자가 되는데, 이것 역시 함수로 할 수 있고,
// 다들 그렇게 쓰고 있다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================



================================================
﻿/////////////////////////////////////////////////////////////////
// 2023.07.06 공부
// Chapter 4 관찰자
// 4.7 미래의 관찰자
/////////////////////////////////////////////////////////////////

#include <iostream>

#include "save.h"



// 이벤트 시스템이나 다른 유사 관찰자 패턴들이 이제는 너무 흔하고 정형화되어 있다.
// 하지만 관찰자 패턴을 이용해 대규모 프로그램을 만들다 보면 관찰자 패턴 관련 코드 중에서 많은 부분이
// 결국에는 다음과 같은 공통점이 있다는 걸 알게 된다.
// 1. 어떤 상태가 변했다는 알림을 받는다.
// 2. 이를 반영하기 위해 UI 상태 일부를 바꾼다.
// '체력이 7이라고? 그럼 체력바 너비를 70픽셀로 바꿀게'라고 하는 식이다. 하다보면 상당히 지겹다.
// 이런 지루함을 제거하기 위해 오랫동안 노력해왔다. 이런 노력은 데이터 흐름 프로그래밍이나
// 함수형 반응형 프로그래밍과 같은 결과로 나타났다.

// 이런 방식은 제한적인 분야에서는 어느 정도 성공을 거뒀으나 아직까지 성배는 찾지 못했다.
// 그 사이 약간 보수적인 접근법이 인기를 얻고 있는데, 요즘 나오는 많은 애플리케이션 프레임워크는 '데이터 바인딩'을 지원한다.
// 데이터 바인딩은 어떤 값이 변경되면 관련된 UI요소나 속성을 바꿔줘야 하는 귀찮은 작업을 알아서 해준다.


int main()
{



	save("GameProgrammingPatternStudy.cpp");
}
================================================
